\doxysection{Memory.\+h}
\hypertarget{_memory_8h_source}{}\label{_memory_8h_source}\index{packages/Eigen.3.3.3/build/native/include/Eigen/src/Core/util/Memory.h@{packages/Eigen.3.3.3/build/native/include/Eigen/src/Core/util/Memory.h}}

\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ \textcolor{comment}{//\ This\ file\ is\ part\ of\ Eigen,\ a\ lightweight\ C++\ template\ library}}
\DoxyCodeLine{00002\ \textcolor{comment}{//\ for\ linear\ algebra.}}
\DoxyCodeLine{00003\ \textcolor{comment}{//}}
\DoxyCodeLine{00004\ \textcolor{comment}{//\ Copyright\ (C)\ 2008-\/2015\ Gael\ Guennebaud\ <gael.guennebaud@inria.fr>}}
\DoxyCodeLine{00005\ \textcolor{comment}{//\ Copyright\ (C)\ 2008-\/2009\ Benoit\ Jacob\ <jacob.benoit.1@gmail.com>}}
\DoxyCodeLine{00006\ \textcolor{comment}{//\ Copyright\ (C)\ 2009\ Kenneth\ Riddile\ <kfriddile@yahoo.com>}}
\DoxyCodeLine{00007\ \textcolor{comment}{//\ Copyright\ (C)\ 2010\ Hauke\ Heibel\ <hauke.heibel@gmail.com>}}
\DoxyCodeLine{00008\ \textcolor{comment}{//\ Copyright\ (C)\ 2010\ Thomas\ Capricelli\ <orzel@freehackers.org>}}
\DoxyCodeLine{00009\ \textcolor{comment}{//\ Copyright\ (C)\ 2013\ Pavel\ Holoborodko\ <pavel@holoborodko.com>}}
\DoxyCodeLine{00010\ \textcolor{comment}{//}}
\DoxyCodeLine{00011\ \textcolor{comment}{//\ This\ Source\ Code\ Form\ is\ subject\ to\ the\ terms\ of\ the\ Mozilla}}
\DoxyCodeLine{00012\ \textcolor{comment}{//\ Public\ License\ v.\ 2.0.\ If\ a\ copy\ of\ the\ MPL\ was\ not\ distributed}}
\DoxyCodeLine{00013\ \textcolor{comment}{//\ with\ this\ file,\ You\ can\ obtain\ one\ at\ http://mozilla.org/MPL/2.0/.}}
\DoxyCodeLine{00014\ }
\DoxyCodeLine{00015\ }
\DoxyCodeLine{00016\ \textcolor{comment}{/*****************************************************************************}}
\DoxyCodeLine{00017\ \textcolor{comment}{***\ Platform\ checks\ for\ aligned\ malloc\ functions\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ***}}
\DoxyCodeLine{00018\ \textcolor{comment}{*****************************************************************************/}}
\DoxyCodeLine{00019\ }
\DoxyCodeLine{00020\ \textcolor{preprocessor}{\#ifndef\ EIGEN\_MEMORY\_H}}
\DoxyCodeLine{00021\ \textcolor{preprocessor}{\#define\ EIGEN\_MEMORY\_H}}
\DoxyCodeLine{00022\ }
\DoxyCodeLine{00023\ \textcolor{preprocessor}{\#ifndef\ EIGEN\_MALLOC\_ALREADY\_ALIGNED}}
\DoxyCodeLine{00024\ }
\DoxyCodeLine{00025\ \textcolor{comment}{//\ Try\ to\ determine\ automatically\ if\ malloc\ is\ already\ aligned.}}
\DoxyCodeLine{00026\ }
\DoxyCodeLine{00027\ \textcolor{comment}{//\ On\ 64-\/bit\ systems,\ glibc's\ malloc\ returns\ 16-\/byte-\/aligned\ pointers,\ see:}}
\DoxyCodeLine{00028\ \textcolor{comment}{//\ \ \ http://www.gnu.org/s/libc/manual/html\_node/Aligned-\/Memory-\/Blocks.html}}
\DoxyCodeLine{00029\ \textcolor{comment}{//\ This\ is\ true\ at\ least\ since\ glibc\ 2.8.}}
\DoxyCodeLine{00030\ \textcolor{comment}{//\ This\ leaves\ the\ question\ how\ to\ detect\ 64-\/bit.\ According\ to\ this\ document,}}
\DoxyCodeLine{00031\ \textcolor{comment}{//\ \ \ http://gcc.fyxm.net/summit/2003/Porting\%20to\%2064\%20bit.pdf}}
\DoxyCodeLine{00032\ \textcolor{comment}{//\ page\ 114,\ "{}[The]\ LP64\ model\ [...]\ is\ used\ by\ all\ 64-\/bit\ UNIX\ ports"{}\ so\ it's\ indeed}}
\DoxyCodeLine{00033\ \textcolor{comment}{//\ quite\ safe,\ at\ least\ within\ the\ context\ of\ glibc,\ to\ equate\ 64-\/bit\ with\ LP64.}}
\DoxyCodeLine{00034\ \textcolor{preprocessor}{\#if\ defined(\_\_GLIBC\_\_)\ \&\&\ ((\_\_GLIBC\_\_>=2\ \&\&\ \_\_GLIBC\_MINOR\_\_\ >=\ 8)\ ||\ \_\_GLIBC\_\_>2)\ \(\backslash\)}}
\DoxyCodeLine{00035\ \textcolor{preprocessor}{\ \&\&\ defined(\_\_LP64\_\_)\ \&\&\ !\ defined(\ \_\_SANITIZE\_ADDRESS\_\_\ )\ \&\&\ (EIGEN\_DEFAULT\_ALIGN\_BYTES\ ==\ 16)}}
\DoxyCodeLine{00036\ \textcolor{preprocessor}{\ \ \#define\ EIGEN\_GLIBC\_MALLOC\_ALREADY\_ALIGNED\ 1}}
\DoxyCodeLine{00037\ \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{00038\ \textcolor{preprocessor}{\ \ \#define\ EIGEN\_GLIBC\_MALLOC\_ALREADY\_ALIGNED\ 0}}
\DoxyCodeLine{00039\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00040\ }
\DoxyCodeLine{00041\ \textcolor{comment}{//\ FreeBSD\ 6\ seems\ to\ have\ 16-\/byte\ aligned\ malloc}}
\DoxyCodeLine{00042\ \textcolor{comment}{//\ \ \ See\ http://svn.freebsd.org/viewvc/base/stable/6/lib/libc/stdlib/malloc.c?view=markup}}
\DoxyCodeLine{00043\ \textcolor{comment}{//\ FreeBSD\ 7\ seems\ to\ have\ 16-\/byte\ aligned\ malloc\ except\ on\ ARM\ and\ MIPS\ architectures}}
\DoxyCodeLine{00044\ \textcolor{comment}{//\ \ \ See\ http://svn.freebsd.org/viewvc/base/stable/7/lib/libc/stdlib/malloc.c?view=markup}}
\DoxyCodeLine{00045\ \textcolor{preprocessor}{\#if\ defined(\_\_FreeBSD\_\_)\ \&\&\ !(EIGEN\_ARCH\_ARM\ ||\ EIGEN\_ARCH\_MIPS)\ \&\&\ (EIGEN\_DEFAULT\_ALIGN\_BYTES\ ==\ 16)}}
\DoxyCodeLine{00046\ \textcolor{preprocessor}{\ \ \#define\ EIGEN\_FREEBSD\_MALLOC\_ALREADY\_ALIGNED\ 1}}
\DoxyCodeLine{00047\ \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{00048\ \textcolor{preprocessor}{\ \ \#define\ EIGEN\_FREEBSD\_MALLOC\_ALREADY\_ALIGNED\ 0}}
\DoxyCodeLine{00049\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00050\ }
\DoxyCodeLine{00051\ \textcolor{preprocessor}{\#if\ (EIGEN\_OS\_MAC\ \&\&\ (EIGEN\_DEFAULT\_ALIGN\_BYTES\ ==\ 16))\ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{00052\ \textcolor{preprocessor}{\ ||\ (EIGEN\_OS\_WIN64\ \&\&\ (EIGEN\_DEFAULT\_ALIGN\_BYTES\ ==\ 16))\ \ \ \(\backslash\)}}
\DoxyCodeLine{00053\ \textcolor{preprocessor}{\ ||\ EIGEN\_GLIBC\_MALLOC\_ALREADY\_ALIGNED\ \ \ \ \ \ \ \ \ \ \ \ \ \ \(\backslash\)}}
\DoxyCodeLine{00054\ \textcolor{preprocessor}{\ ||\ EIGEN\_FREEBSD\_MALLOC\_ALREADY\_ALIGNED}}
\DoxyCodeLine{00055\ \textcolor{preprocessor}{\ \ \#define\ EIGEN\_MALLOC\_ALREADY\_ALIGNED\ 1}}
\DoxyCodeLine{00056\ \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{00057\ \textcolor{preprocessor}{\ \ \#define\ EIGEN\_MALLOC\_ALREADY\_ALIGNED\ 0}}
\DoxyCodeLine{00058\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00059\ }
\DoxyCodeLine{00060\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00061\ }
\DoxyCodeLine{00062\ \textcolor{keyword}{namespace\ }Eigen\ \{}
\DoxyCodeLine{00063\ }
\DoxyCodeLine{00064\ \textcolor{keyword}{namespace\ }internal\ \{}
\DoxyCodeLine{00065\ }
\DoxyCodeLine{00066\ EIGEN\_DEVICE\_FUNC\ }
\DoxyCodeLine{00067\ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{void}\ throw\_std\_bad\_alloc()}
\DoxyCodeLine{00068\ \{}
\DoxyCodeLine{00069\ \textcolor{preprocessor}{\ \ \#ifdef\ EIGEN\_EXCEPTIONS}}
\DoxyCodeLine{00070\ \ \ \ \ \textcolor{keywordflow}{throw}\ std::bad\_alloc();}
\DoxyCodeLine{00071\ \textcolor{preprocessor}{\ \ \#else}}
\DoxyCodeLine{00072\ \ \ \ \ std::size\_t\ huge\ =\ \textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(-\/1);}
\DoxyCodeLine{00073\ \ \ \ \ \textcolor{keyword}{new}\ \textcolor{keywordtype}{int}[huge];}
\DoxyCodeLine{00074\ \textcolor{preprocessor}{\ \ \#endif}}
\DoxyCodeLine{00075\ \}}
\DoxyCodeLine{00076\ }
\DoxyCodeLine{00077\ \textcolor{comment}{/*****************************************************************************}}
\DoxyCodeLine{00078\ \textcolor{comment}{***\ Implementation\ of\ handmade\ aligned\ functions\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ***}}
\DoxyCodeLine{00079\ \textcolor{comment}{*****************************************************************************/}}
\DoxyCodeLine{00080\ }
\DoxyCodeLine{00081\ \textcolor{comment}{/*\ -\/-\/-\/-\/-\/\ Hand\ made\ implementations\ of\ aligned\ malloc/free\ and\ realloc\ -\/-\/-\/-\/-\/\ */}}
\DoxyCodeLine{00082\ }
\DoxyCodeLine{00086\ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{void}*\ handmade\_aligned\_malloc(std::size\_t\ size)}
\DoxyCodeLine{00087\ \{}
\DoxyCodeLine{00088\ \ \ \textcolor{keywordtype}{void}\ *original\ =\ std::malloc(size+EIGEN\_DEFAULT\_ALIGN\_BYTES);}
\DoxyCodeLine{00089\ \ \ \textcolor{keywordflow}{if}\ (original\ ==\ 0)\ \textcolor{keywordflow}{return}\ 0;}
\DoxyCodeLine{00090\ \ \ \textcolor{keywordtype}{void}\ *aligned\ =\ \textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{void}*\textcolor{keyword}{>}((\textcolor{keyword}{reinterpret\_cast<}std::size\_t\textcolor{keyword}{>}(original)\ \&\ \string~(std::size\_t(EIGEN\_DEFAULT\_ALIGN\_BYTES-\/1)))\ +\ EIGEN\_DEFAULT\_ALIGN\_BYTES);}
\DoxyCodeLine{00091\ \ \ *(\textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{void}**\textcolor{keyword}{>}(aligned)\ -\/\ 1)\ =\ original;}
\DoxyCodeLine{00092\ \ \ \textcolor{keywordflow}{return}\ aligned;}
\DoxyCodeLine{00093\ \}}
\DoxyCodeLine{00094\ }
\DoxyCodeLine{00096\ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{void}\ handmade\_aligned\_free(\textcolor{keywordtype}{void}\ *ptr)}
\DoxyCodeLine{00097\ \{}
\DoxyCodeLine{00098\ \ \ \textcolor{keywordflow}{if}\ (ptr)\ std::free(*(\textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{void}**\textcolor{keyword}{>}(ptr)\ -\/\ 1));}
\DoxyCodeLine{00099\ \}}
\DoxyCodeLine{00100\ }
\DoxyCodeLine{00106\ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{void}*\ handmade\_aligned\_realloc(\textcolor{keywordtype}{void}*\ ptr,\ std::size\_t\ size,\ std::size\_t\ =\ 0)}
\DoxyCodeLine{00107\ \{}
\DoxyCodeLine{00108\ \ \ \textcolor{keywordflow}{if}\ (ptr\ ==\ 0)\ \textcolor{keywordflow}{return}\ handmade\_aligned\_malloc(size);}
\DoxyCodeLine{00109\ \ \ \textcolor{keywordtype}{void}\ *original\ =\ *(\textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{void}**\textcolor{keyword}{>}(ptr)\ -\/\ 1);}
\DoxyCodeLine{00110\ \ \ std::ptrdiff\_t\ previous\_offset\ =\ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\ *\textcolor{keyword}{>}(ptr)-\/\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\ *\textcolor{keyword}{>}(original);}
\DoxyCodeLine{00111\ \ \ original\ =\ std::realloc(original,size+EIGEN\_DEFAULT\_ALIGN\_BYTES);}
\DoxyCodeLine{00112\ \ \ \textcolor{keywordflow}{if}\ (original\ ==\ 0)\ \textcolor{keywordflow}{return}\ 0;}
\DoxyCodeLine{00113\ \ \ \textcolor{keywordtype}{void}\ *aligned\ =\ \textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{void}*\textcolor{keyword}{>}((\textcolor{keyword}{reinterpret\_cast<}std::size\_t\textcolor{keyword}{>}(original)\ \&\ \string~(std::size\_t(EIGEN\_DEFAULT\_ALIGN\_BYTES-\/1)))\ +\ EIGEN\_DEFAULT\_ALIGN\_BYTES);}
\DoxyCodeLine{00114\ \ \ \textcolor{keywordtype}{void}\ *previous\_aligned\ =\ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\ *\textcolor{keyword}{>}(original)+previous\_offset;}
\DoxyCodeLine{00115\ \ \ \textcolor{keywordflow}{if}(aligned!=previous\_aligned)}
\DoxyCodeLine{00116\ \ \ \ \ std::memmove(aligned,\ previous\_aligned,\ size);}
\DoxyCodeLine{00117\ \ \ }
\DoxyCodeLine{00118\ \ \ *(\textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{void}**\textcolor{keyword}{>}(aligned)\ -\/\ 1)\ =\ original;}
\DoxyCodeLine{00119\ \ \ \textcolor{keywordflow}{return}\ aligned;}
\DoxyCodeLine{00120\ \}}
\DoxyCodeLine{00121\ }
\DoxyCodeLine{00122\ \textcolor{comment}{/*****************************************************************************}}
\DoxyCodeLine{00123\ \textcolor{comment}{***\ Implementation\ of\ portable\ aligned\ versions\ of\ malloc/free/realloc\ \ \ \ \ ***}}
\DoxyCodeLine{00124\ \textcolor{comment}{*****************************************************************************/}}
\DoxyCodeLine{00125\ }
\DoxyCodeLine{00126\ \textcolor{preprocessor}{\#ifdef\ EIGEN\_NO\_MALLOC}}
\DoxyCodeLine{00127\ EIGEN\_DEVICE\_FUNC\ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{void}\ check\_that\_malloc\_is\_allowed()}
\DoxyCodeLine{00128\ \{}
\DoxyCodeLine{00129\ \ \ eigen\_assert(\textcolor{keyword}{false}\ \&\&\ \textcolor{stringliteral}{"{}heap\ allocation\ is\ forbidden\ (EIGEN\_NO\_MALLOC\ is\ defined)"{}});}
\DoxyCodeLine{00130\ \}}
\DoxyCodeLine{00131\ \textcolor{preprocessor}{\#elif\ defined\ EIGEN\_RUNTIME\_NO\_MALLOC}}
\DoxyCodeLine{00132\ EIGEN\_DEVICE\_FUNC\ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{bool}\ is\_malloc\_allowed\_impl(\textcolor{keywordtype}{bool}\ update,\ \textcolor{keywordtype}{bool}\ new\_value\ =\ \textcolor{keyword}{false})}
\DoxyCodeLine{00133\ \{}
\DoxyCodeLine{00134\ \ \ \textcolor{keyword}{static}\ \textcolor{keywordtype}{bool}\ value\ =\ \textcolor{keyword}{true};}
\DoxyCodeLine{00135\ \ \ \textcolor{keywordflow}{if}\ (update\ ==\ 1)}
\DoxyCodeLine{00136\ \ \ \ \ value\ =\ new\_value;}
\DoxyCodeLine{00137\ \ \ \textcolor{keywordflow}{return}\ value;}
\DoxyCodeLine{00138\ \}}
\DoxyCodeLine{00139\ EIGEN\_DEVICE\_FUNC\ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{bool}\ is\_malloc\_allowed()\ \{\ \textcolor{keywordflow}{return}\ is\_malloc\_allowed\_impl(\textcolor{keyword}{false});\ \}}
\DoxyCodeLine{00140\ EIGEN\_DEVICE\_FUNC\ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{bool}\ set\_is\_malloc\_allowed(\textcolor{keywordtype}{bool}\ new\_value)\ \{\ \textcolor{keywordflow}{return}\ is\_malloc\_allowed\_impl(\textcolor{keyword}{true},\ new\_value);\ \}}
\DoxyCodeLine{00141\ EIGEN\_DEVICE\_FUNC\ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{void}\ check\_that\_malloc\_is\_allowed()}
\DoxyCodeLine{00142\ \{}
\DoxyCodeLine{00143\ \ \ eigen\_assert(is\_malloc\_allowed()\ \&\&\ \textcolor{stringliteral}{"{}heap\ allocation\ is\ forbidden\ (EIGEN\_RUNTIME\_NO\_MALLOC\ is\ defined\ and\ g\_is\_malloc\_allowed\ is\ false)"{}});}
\DoxyCodeLine{00144\ \}}
\DoxyCodeLine{00145\ \textcolor{preprocessor}{\#else\ }}
\DoxyCodeLine{00146\ EIGEN\_DEVICE\_FUNC\ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{void}\ check\_that\_malloc\_is\_allowed()}
\DoxyCodeLine{00147\ \{\}}
\DoxyCodeLine{00148\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00149\ }
\DoxyCodeLine{00153\ EIGEN\_DEVICE\_FUNC\ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{void}*\ aligned\_malloc(std::size\_t\ size)}
\DoxyCodeLine{00154\ \{}
\DoxyCodeLine{00155\ \ \ check\_that\_malloc\_is\_allowed();}
\DoxyCodeLine{00156\ }
\DoxyCodeLine{00157\ \ \ \textcolor{keywordtype}{void}\ *result;}
\DoxyCodeLine{00158\ \textcolor{preprocessor}{\ \ \#if\ (EIGEN\_DEFAULT\_ALIGN\_BYTES==0)\ ||\ EIGEN\_MALLOC\_ALREADY\_ALIGNED}}
\DoxyCodeLine{00159\ \ \ \ \ result\ =\ std::malloc(size);}
\DoxyCodeLine{00160\ \textcolor{preprocessor}{\ \ \ \ \#if\ EIGEN\_DEFAULT\_ALIGN\_BYTES==16}}
\DoxyCodeLine{00161\ \ \ \ \ eigen\_assert((size<16\ ||\ (std::size\_t(result)\%16)==0)\ \&\&\ \textcolor{stringliteral}{"{}System's\ malloc\ returned\ an\ unaligned\ pointer.\ Compile\ with\ EIGEN\_MALLOC\_ALREADY\_ALIGNED=0\ to\ fallback\ to\ handmade\ alignd\ memory\ allocator."{}});}
\DoxyCodeLine{00162\ \textcolor{preprocessor}{\ \ \ \ \#endif}}
\DoxyCodeLine{00163\ \textcolor{preprocessor}{\ \ \#else}}
\DoxyCodeLine{00164\ \ \ \ \ result\ =\ handmade\_aligned\_malloc(size);}
\DoxyCodeLine{00165\ \textcolor{preprocessor}{\ \ \#endif}}
\DoxyCodeLine{00166\ }
\DoxyCodeLine{00167\ \ \ \textcolor{keywordflow}{if}(!result\ \&\&\ size)}
\DoxyCodeLine{00168\ \ \ \ \ throw\_std\_bad\_alloc();}
\DoxyCodeLine{00169\ }
\DoxyCodeLine{00170\ \ \ \textcolor{keywordflow}{return}\ result;}
\DoxyCodeLine{00171\ \}}
\DoxyCodeLine{00172\ }
\DoxyCodeLine{00174\ EIGEN\_DEVICE\_FUNC\ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{void}\ aligned\_free(\textcolor{keywordtype}{void}\ *ptr)}
\DoxyCodeLine{00175\ \{}
\DoxyCodeLine{00176\ \textcolor{preprocessor}{\ \ \#if\ (EIGEN\_DEFAULT\_ALIGN\_BYTES==0)\ ||\ EIGEN\_MALLOC\_ALREADY\_ALIGNED}}
\DoxyCodeLine{00177\ \ \ \ \ std::free(ptr);}
\DoxyCodeLine{00178\ \textcolor{preprocessor}{\ \ \#else}}
\DoxyCodeLine{00179\ \ \ \ \ handmade\_aligned\_free(ptr);}
\DoxyCodeLine{00180\ \textcolor{preprocessor}{\ \ \#endif}}
\DoxyCodeLine{00181\ \}}
\DoxyCodeLine{00182\ }
\DoxyCodeLine{00188\ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{void}*\ aligned\_realloc(\textcolor{keywordtype}{void}\ *ptr,\ std::size\_t\ new\_size,\ std::size\_t\ old\_size)}
\DoxyCodeLine{00189\ \{}
\DoxyCodeLine{00190\ \ \ EIGEN\_UNUSED\_VARIABLE(old\_size);}
\DoxyCodeLine{00191\ }
\DoxyCodeLine{00192\ \ \ \textcolor{keywordtype}{void}\ *result;}
\DoxyCodeLine{00193\ \textcolor{preprocessor}{\#if\ (EIGEN\_DEFAULT\_ALIGN\_BYTES==0)\ ||\ EIGEN\_MALLOC\_ALREADY\_ALIGNED}}
\DoxyCodeLine{00194\ \ \ result\ =\ std::realloc(ptr,new\_size);}
\DoxyCodeLine{00195\ \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{00196\ \ \ result\ =\ handmade\_aligned\_realloc(ptr,new\_size,old\_size);}
\DoxyCodeLine{00197\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00198\ }
\DoxyCodeLine{00199\ \ \ \textcolor{keywordflow}{if}\ (!result\ \&\&\ new\_size)}
\DoxyCodeLine{00200\ \ \ \ \ throw\_std\_bad\_alloc();}
\DoxyCodeLine{00201\ }
\DoxyCodeLine{00202\ \ \ \textcolor{keywordflow}{return}\ result;}
\DoxyCodeLine{00203\ \}}
\DoxyCodeLine{00204\ }
\DoxyCodeLine{00205\ \textcolor{comment}{/*****************************************************************************}}
\DoxyCodeLine{00206\ \textcolor{comment}{***\ Implementation\ of\ conditionally\ aligned\ functions\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ***}}
\DoxyCodeLine{00207\ \textcolor{comment}{*****************************************************************************/}}
\DoxyCodeLine{00208\ }
\DoxyCodeLine{00212\ \textcolor{keyword}{template}<\textcolor{keywordtype}{bool}\ Align>\ EIGEN\_DEVICE\_FUNC\ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{void}*\ conditional\_aligned\_malloc(std::size\_t\ size)}
\DoxyCodeLine{00213\ \{}
\DoxyCodeLine{00214\ \ \ \textcolor{keywordflow}{return}\ aligned\_malloc(size);}
\DoxyCodeLine{00215\ \}}
\DoxyCodeLine{00216\ }
\DoxyCodeLine{00217\ \textcolor{keyword}{template}<>\ EIGEN\_DEVICE\_FUNC\ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{void}*\ conditional\_aligned\_malloc<false>(std::size\_t\ size)}
\DoxyCodeLine{00218\ \{}
\DoxyCodeLine{00219\ \ \ check\_that\_malloc\_is\_allowed();}
\DoxyCodeLine{00220\ }
\DoxyCodeLine{00221\ \ \ \textcolor{keywordtype}{void}\ *result\ =\ std::malloc(size);}
\DoxyCodeLine{00222\ \ \ \textcolor{keywordflow}{if}(!result\ \&\&\ size)}
\DoxyCodeLine{00223\ \ \ \ \ throw\_std\_bad\_alloc();}
\DoxyCodeLine{00224\ \ \ \textcolor{keywordflow}{return}\ result;}
\DoxyCodeLine{00225\ \}}
\DoxyCodeLine{00226\ }
\DoxyCodeLine{00228\ \textcolor{keyword}{template}<\textcolor{keywordtype}{bool}\ Align>\ EIGEN\_DEVICE\_FUNC\ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{void}\ conditional\_aligned\_free(\textcolor{keywordtype}{void}\ *ptr)}
\DoxyCodeLine{00229\ \{}
\DoxyCodeLine{00230\ \ \ aligned\_free(ptr);}
\DoxyCodeLine{00231\ \}}
\DoxyCodeLine{00232\ }
\DoxyCodeLine{00233\ \textcolor{keyword}{template}<>\ EIGEN\_DEVICE\_FUNC\ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{void}\ conditional\_aligned\_free<false>(\textcolor{keywordtype}{void}\ *ptr)}
\DoxyCodeLine{00234\ \{}
\DoxyCodeLine{00235\ \ \ std::free(ptr);}
\DoxyCodeLine{00236\ \}}
\DoxyCodeLine{00237\ }
\DoxyCodeLine{00238\ \textcolor{keyword}{template}<\textcolor{keywordtype}{bool}\ Align>\ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{void}*\ conditional\_aligned\_realloc(\textcolor{keywordtype}{void}*\ ptr,\ std::size\_t\ new\_size,\ std::size\_t\ old\_size)}
\DoxyCodeLine{00239\ \{}
\DoxyCodeLine{00240\ \ \ \textcolor{keywordflow}{return}\ aligned\_realloc(ptr,\ new\_size,\ old\_size);}
\DoxyCodeLine{00241\ \}}
\DoxyCodeLine{00242\ }
\DoxyCodeLine{00243\ \textcolor{keyword}{template}<>\ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{void}*\ conditional\_aligned\_realloc<false>(\textcolor{keywordtype}{void}*\ ptr,\ std::size\_t\ new\_size,\ std::size\_t)}
\DoxyCodeLine{00244\ \{}
\DoxyCodeLine{00245\ \ \ \textcolor{keywordflow}{return}\ std::realloc(ptr,\ new\_size);}
\DoxyCodeLine{00246\ \}}
\DoxyCodeLine{00247\ }
\DoxyCodeLine{00248\ \textcolor{comment}{/*****************************************************************************}}
\DoxyCodeLine{00249\ \textcolor{comment}{***\ Construction/destruction\ of\ array\ elements\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ***}}
\DoxyCodeLine{00250\ \textcolor{comment}{*****************************************************************************/}}
\DoxyCodeLine{00251\ }
\DoxyCodeLine{00255\ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ T>\ EIGEN\_DEVICE\_FUNC\ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{void}\ destruct\_elements\_of\_array(T\ *ptr,\ std::size\_t\ size)}
\DoxyCodeLine{00256\ \{}
\DoxyCodeLine{00257\ \ \ \textcolor{comment}{//\ always\ destruct\ an\ array\ starting\ from\ the\ end.}}
\DoxyCodeLine{00258\ \ \ \textcolor{keywordflow}{if}(ptr)}
\DoxyCodeLine{00259\ \ \ \ \ \textcolor{keywordflow}{while}(size)\ ptr[-\/-\/size].\string~T();}
\DoxyCodeLine{00260\ \}}
\DoxyCodeLine{00261\ }
\DoxyCodeLine{00265\ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ T>\ EIGEN\_DEVICE\_FUNC\ \textcolor{keyword}{inline}\ T*\ construct\_elements\_of\_array(T\ *ptr,\ std::size\_t\ size)}
\DoxyCodeLine{00266\ \{}
\DoxyCodeLine{00267\ \ \ std::size\_t\ i;}
\DoxyCodeLine{00268\ \ \ EIGEN\_TRY}
\DoxyCodeLine{00269\ \ \ \{}
\DoxyCodeLine{00270\ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (i\ =\ 0;\ i\ <\ size;\ ++i)\ ::new\ (ptr\ +\ i)\ T;}
\DoxyCodeLine{00271\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ ptr;}
\DoxyCodeLine{00272\ \ \ \}}
\DoxyCodeLine{00273\ \ \ EIGEN\_CATCH(...)}
\DoxyCodeLine{00274\ \ \ \{}
\DoxyCodeLine{00275\ \ \ \ \ destruct\_elements\_of\_array(ptr,\ i);}
\DoxyCodeLine{00276\ \ \ \ \ EIGEN\_THROW;}
\DoxyCodeLine{00277\ \ \ \}}
\DoxyCodeLine{00278\ \ \ \textcolor{keywordflow}{return}\ NULL;}
\DoxyCodeLine{00279\ \}}
\DoxyCodeLine{00280\ }
\DoxyCodeLine{00281\ \textcolor{comment}{/*****************************************************************************}}
\DoxyCodeLine{00282\ \textcolor{comment}{***\ Implementation\ of\ aligned\ new/delete-\/like\ functions\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ***}}
\DoxyCodeLine{00283\ \textcolor{comment}{*****************************************************************************/}}
\DoxyCodeLine{00284\ }
\DoxyCodeLine{00285\ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{00286\ EIGEN\_DEVICE\_FUNC\ EIGEN\_ALWAYS\_INLINE\ \textcolor{keywordtype}{void}\ check\_size\_for\_overflow(std::size\_t\ size)}
\DoxyCodeLine{00287\ \{}
\DoxyCodeLine{00288\ \ \ \textcolor{keywordflow}{if}(size\ >\ std::size\_t(-\/1)\ /\ \textcolor{keyword}{sizeof}(T))}
\DoxyCodeLine{00289\ \ \ \ \ throw\_std\_bad\_alloc();}
\DoxyCodeLine{00290\ \}}
\DoxyCodeLine{00291\ }
\DoxyCodeLine{00296\ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ T>\ EIGEN\_DEVICE\_FUNC\ \textcolor{keyword}{inline}\ T*\ aligned\_new(std::size\_t\ size)}
\DoxyCodeLine{00297\ \{}
\DoxyCodeLine{00298\ \ \ check\_size\_for\_overflow<T>(size);}
\DoxyCodeLine{00299\ \ \ T\ *result\ =\ \textcolor{keyword}{reinterpret\_cast<}T*\textcolor{keyword}{>}(aligned\_malloc(\textcolor{keyword}{sizeof}(T)*size));}
\DoxyCodeLine{00300\ \ \ EIGEN\_TRY}
\DoxyCodeLine{00301\ \ \ \{}
\DoxyCodeLine{00302\ \ \ \ \ \textcolor{keywordflow}{return}\ construct\_elements\_of\_array(result,\ size);}
\DoxyCodeLine{00303\ \ \ \}}
\DoxyCodeLine{00304\ \ \ EIGEN\_CATCH(...)}
\DoxyCodeLine{00305\ \ \ \{}
\DoxyCodeLine{00306\ \ \ \ \ aligned\_free(result);}
\DoxyCodeLine{00307\ \ \ \ \ EIGEN\_THROW;}
\DoxyCodeLine{00308\ \ \ \}}
\DoxyCodeLine{00309\ \ \ \textcolor{keywordflow}{return}\ result;}
\DoxyCodeLine{00310\ \}}
\DoxyCodeLine{00311\ }
\DoxyCodeLine{00312\ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ T,\ \textcolor{keywordtype}{bool}\ Align>\ EIGEN\_DEVICE\_FUNC\ \textcolor{keyword}{inline}\ T*\ conditional\_aligned\_new(std::size\_t\ size)}
\DoxyCodeLine{00313\ \{}
\DoxyCodeLine{00314\ \ \ check\_size\_for\_overflow<T>(size);}
\DoxyCodeLine{00315\ \ \ T\ *result\ =\ \textcolor{keyword}{reinterpret\_cast<}T*\textcolor{keyword}{>}(conditional\_aligned\_malloc<Align>(\textcolor{keyword}{sizeof}(T)*size));}
\DoxyCodeLine{00316\ \ \ EIGEN\_TRY}
\DoxyCodeLine{00317\ \ \ \{}
\DoxyCodeLine{00318\ \ \ \ \ \textcolor{keywordflow}{return}\ construct\_elements\_of\_array(result,\ size);}
\DoxyCodeLine{00319\ \ \ \}}
\DoxyCodeLine{00320\ \ \ EIGEN\_CATCH(...)}
\DoxyCodeLine{00321\ \ \ \{}
\DoxyCodeLine{00322\ \ \ \ \ conditional\_aligned\_free<Align>(result);}
\DoxyCodeLine{00323\ \ \ \ \ EIGEN\_THROW;}
\DoxyCodeLine{00324\ \ \ \}}
\DoxyCodeLine{00325\ \ \ \textcolor{keywordflow}{return}\ result;}
\DoxyCodeLine{00326\ \}}
\DoxyCodeLine{00327\ }
\DoxyCodeLine{00331\ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ T>\ EIGEN\_DEVICE\_FUNC\ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{void}\ aligned\_delete(T\ *ptr,\ std::size\_t\ size)}
\DoxyCodeLine{00332\ \{}
\DoxyCodeLine{00333\ \ \ destruct\_elements\_of\_array<T>(ptr,\ size);}
\DoxyCodeLine{00334\ \ \ aligned\_free(ptr);}
\DoxyCodeLine{00335\ \}}
\DoxyCodeLine{00336\ }
\DoxyCodeLine{00340\ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ T,\ \textcolor{keywordtype}{bool}\ Align>\ EIGEN\_DEVICE\_FUNC\ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{void}\ conditional\_aligned\_delete(T\ *ptr,\ std::size\_t\ size)}
\DoxyCodeLine{00341\ \{}
\DoxyCodeLine{00342\ \ \ destruct\_elements\_of\_array<T>(ptr,\ size);}
\DoxyCodeLine{00343\ \ \ conditional\_aligned\_free<Align>(ptr);}
\DoxyCodeLine{00344\ \}}
\DoxyCodeLine{00345\ }
\DoxyCodeLine{00346\ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ T,\ \textcolor{keywordtype}{bool}\ Align>\ EIGEN\_DEVICE\_FUNC\ \textcolor{keyword}{inline}\ T*\ conditional\_aligned\_realloc\_new(T*\ pts,\ std::size\_t\ new\_size,\ std::size\_t\ old\_size)}
\DoxyCodeLine{00347\ \{}
\DoxyCodeLine{00348\ \ \ check\_size\_for\_overflow<T>(new\_size);}
\DoxyCodeLine{00349\ \ \ check\_size\_for\_overflow<T>(old\_size);}
\DoxyCodeLine{00350\ \ \ \textcolor{keywordflow}{if}(new\_size\ <\ old\_size)}
\DoxyCodeLine{00351\ \ \ \ \ destruct\_elements\_of\_array(pts+new\_size,\ old\_size-\/new\_size);}
\DoxyCodeLine{00352\ \ \ T\ *result\ =\ \textcolor{keyword}{reinterpret\_cast<}T*\textcolor{keyword}{>}(conditional\_aligned\_realloc<Align>(\textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{void}*\textcolor{keyword}{>}(pts),\ \textcolor{keyword}{sizeof}(T)*new\_size,\ \textcolor{keyword}{sizeof}(T)*old\_size));}
\DoxyCodeLine{00353\ \ \ \textcolor{keywordflow}{if}(new\_size\ >\ old\_size)}
\DoxyCodeLine{00354\ \ \ \{}
\DoxyCodeLine{00355\ \ \ \ \ EIGEN\_TRY}
\DoxyCodeLine{00356\ \ \ \ \ \{}
\DoxyCodeLine{00357\ \ \ \ \ \ \ construct\_elements\_of\_array(result+old\_size,\ new\_size-\/old\_size);}
\DoxyCodeLine{00358\ \ \ \ \ \}}
\DoxyCodeLine{00359\ \ \ \ \ EIGEN\_CATCH(...)}
\DoxyCodeLine{00360\ \ \ \ \ \{}
\DoxyCodeLine{00361\ \ \ \ \ \ \ conditional\_aligned\_free<Align>(result);}
\DoxyCodeLine{00362\ \ \ \ \ \ \ EIGEN\_THROW;}
\DoxyCodeLine{00363\ \ \ \ \ \}}
\DoxyCodeLine{00364\ \ \ \}}
\DoxyCodeLine{00365\ \ \ \textcolor{keywordflow}{return}\ result;}
\DoxyCodeLine{00366\ \}}
\DoxyCodeLine{00367\ }
\DoxyCodeLine{00368\ }
\DoxyCodeLine{00369\ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ T,\ \textcolor{keywordtype}{bool}\ Align>\ EIGEN\_DEVICE\_FUNC\ \textcolor{keyword}{inline}\ T*\ conditional\_aligned\_new\_auto(std::size\_t\ size)}
\DoxyCodeLine{00370\ \{}
\DoxyCodeLine{00371\ \ \ \textcolor{keywordflow}{if}(size==0)}
\DoxyCodeLine{00372\ \ \ \ \ \textcolor{keywordflow}{return}\ 0;\ \textcolor{comment}{//\ short-\/cut.\ Also\ fixes\ Bug\ 884}}
\DoxyCodeLine{00373\ \ \ check\_size\_for\_overflow<T>(size);}
\DoxyCodeLine{00374\ \ \ T\ *result\ =\ \textcolor{keyword}{reinterpret\_cast<}T*\textcolor{keyword}{>}(conditional\_aligned\_malloc<Align>(\textcolor{keyword}{sizeof}(T)*size));}
\DoxyCodeLine{00375\ \ \ \textcolor{keywordflow}{if}(NumTraits<T>::RequireInitialization)}
\DoxyCodeLine{00376\ \ \ \{}
\DoxyCodeLine{00377\ \ \ \ \ EIGEN\_TRY}
\DoxyCodeLine{00378\ \ \ \ \ \{}
\DoxyCodeLine{00379\ \ \ \ \ \ \ construct\_elements\_of\_array(result,\ size);}
\DoxyCodeLine{00380\ \ \ \ \ \}}
\DoxyCodeLine{00381\ \ \ \ \ EIGEN\_CATCH(...)}
\DoxyCodeLine{00382\ \ \ \ \ \{}
\DoxyCodeLine{00383\ \ \ \ \ \ \ conditional\_aligned\_free<Align>(result);}
\DoxyCodeLine{00384\ \ \ \ \ \ \ EIGEN\_THROW;}
\DoxyCodeLine{00385\ \ \ \ \ \}}
\DoxyCodeLine{00386\ \ \ \}}
\DoxyCodeLine{00387\ \ \ \textcolor{keywordflow}{return}\ result;}
\DoxyCodeLine{00388\ \}}
\DoxyCodeLine{00389\ }
\DoxyCodeLine{00390\ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ T,\ \textcolor{keywordtype}{bool}\ Align>\ \textcolor{keyword}{inline}\ T*\ conditional\_aligned\_realloc\_new\_auto(T*\ pts,\ std::size\_t\ new\_size,\ std::size\_t\ old\_size)}
\DoxyCodeLine{00391\ \{}
\DoxyCodeLine{00392\ \ \ check\_size\_for\_overflow<T>(new\_size);}
\DoxyCodeLine{00393\ \ \ check\_size\_for\_overflow<T>(old\_size);}
\DoxyCodeLine{00394\ \ \ \textcolor{keywordflow}{if}(NumTraits<T>::RequireInitialization\ \&\&\ (new\_size\ <\ old\_size))}
\DoxyCodeLine{00395\ \ \ \ \ destruct\_elements\_of\_array(pts+new\_size,\ old\_size-\/new\_size);}
\DoxyCodeLine{00396\ \ \ T\ *result\ =\ \textcolor{keyword}{reinterpret\_cast<}T*\textcolor{keyword}{>}(conditional\_aligned\_realloc<Align>(\textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{void}*\textcolor{keyword}{>}(pts),\ \textcolor{keyword}{sizeof}(T)*new\_size,\ \textcolor{keyword}{sizeof}(T)*old\_size));}
\DoxyCodeLine{00397\ \ \ \textcolor{keywordflow}{if}(NumTraits<T>::RequireInitialization\ \&\&\ (new\_size\ >\ old\_size))}
\DoxyCodeLine{00398\ \ \ \{}
\DoxyCodeLine{00399\ \ \ \ \ EIGEN\_TRY}
\DoxyCodeLine{00400\ \ \ \ \ \{}
\DoxyCodeLine{00401\ \ \ \ \ \ \ construct\_elements\_of\_array(result+old\_size,\ new\_size-\/old\_size);}
\DoxyCodeLine{00402\ \ \ \ \ \}}
\DoxyCodeLine{00403\ \ \ \ \ EIGEN\_CATCH(...)}
\DoxyCodeLine{00404\ \ \ \ \ \{}
\DoxyCodeLine{00405\ \ \ \ \ \ \ conditional\_aligned\_free<Align>(result);}
\DoxyCodeLine{00406\ \ \ \ \ \ \ EIGEN\_THROW;}
\DoxyCodeLine{00407\ \ \ \ \ \}}
\DoxyCodeLine{00408\ \ \ \}}
\DoxyCodeLine{00409\ \ \ \textcolor{keywordflow}{return}\ result;}
\DoxyCodeLine{00410\ \}}
\DoxyCodeLine{00411\ }
\DoxyCodeLine{00412\ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ T,\ \textcolor{keywordtype}{bool}\ Align>\ EIGEN\_DEVICE\_FUNC\ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{void}\ conditional\_aligned\_delete\_auto(T\ *ptr,\ std::size\_t\ size)}
\DoxyCodeLine{00413\ \{}
\DoxyCodeLine{00414\ \ \ \textcolor{keywordflow}{if}(NumTraits<T>::RequireInitialization)}
\DoxyCodeLine{00415\ \ \ \ \ destruct\_elements\_of\_array<T>(ptr,\ size);}
\DoxyCodeLine{00416\ \ \ conditional\_aligned\_free<Align>(ptr);}
\DoxyCodeLine{00417\ \}}
\DoxyCodeLine{00418\ }
\DoxyCodeLine{00419\ \textcolor{comment}{/****************************************************************************/}}
\DoxyCodeLine{00420\ }
\DoxyCodeLine{00438\ \textcolor{keyword}{template}<\textcolor{keywordtype}{int}\ Alignment,\ \textcolor{keyword}{typename}\ Scalar,\ \textcolor{keyword}{typename}\ Index>}
\DoxyCodeLine{00439\ EIGEN\_DEVICE\_FUNC\ \textcolor{keyword}{inline}\ Index\ first\_aligned(\textcolor{keyword}{const}\ Scalar*\ array,\ Index\ size)}
\DoxyCodeLine{00440\ \{}
\DoxyCodeLine{00441\ \ \ \textcolor{keyword}{const}\ Index\ ScalarSize\ =\ \textcolor{keyword}{sizeof}(Scalar);}
\DoxyCodeLine{00442\ \ \ \textcolor{keyword}{const}\ Index\ AlignmentSize\ =\ Alignment\ /\ ScalarSize;}
\DoxyCodeLine{00443\ \ \ \textcolor{keyword}{const}\ Index\ AlignmentMask\ =\ AlignmentSize-\/1;}
\DoxyCodeLine{00444\ }
\DoxyCodeLine{00445\ \ \ \textcolor{keywordflow}{if}(AlignmentSize<=1)}
\DoxyCodeLine{00446\ \ \ \{}
\DoxyCodeLine{00447\ \ \ \ \ \textcolor{comment}{//\ Either\ the\ requested\ alignment\ if\ smaller\ than\ a\ scalar,\ or\ it\ exactly\ match\ a\ 1\ scalar}}
\DoxyCodeLine{00448\ \ \ \ \ \textcolor{comment}{//\ so\ that\ all\ elements\ of\ the\ array\ have\ the\ same\ alignment.}}
\DoxyCodeLine{00449\ \ \ \ \ \textcolor{keywordflow}{return}\ 0;}
\DoxyCodeLine{00450\ \ \ \}}
\DoxyCodeLine{00451\ \ \ \textcolor{keywordflow}{else}\ \textcolor{keywordflow}{if}(\ (UIntPtr(array)\ \&\ (\textcolor{keyword}{sizeof}(Scalar)-\/1))\ ||\ (Alignment\%ScalarSize)!=0)}
\DoxyCodeLine{00452\ \ \ \{}
\DoxyCodeLine{00453\ \ \ \ \ \textcolor{comment}{//\ The\ array\ is\ not\ aligned\ to\ the\ size\ of\ a\ single\ scalar,\ or\ the\ requested\ alignment\ is\ not\ a\ multiple\ of\ the\ scalar\ size.}}
\DoxyCodeLine{00454\ \ \ \ \ \textcolor{comment}{//\ Consequently,\ no\ element\ of\ the\ array\ is\ well\ aligned.}}
\DoxyCodeLine{00455\ \ \ \ \ \textcolor{keywordflow}{return}\ size;}
\DoxyCodeLine{00456\ \ \ \}}
\DoxyCodeLine{00457\ \ \ \textcolor{keywordflow}{else}}
\DoxyCodeLine{00458\ \ \ \{}
\DoxyCodeLine{00459\ \ \ \ \ Index\ first\ =\ (AlignmentSize\ -\/\ (Index((UIntPtr(array)/\textcolor{keyword}{sizeof}(Scalar)))\ \&\ AlignmentMask))\ \&\ AlignmentMask;}
\DoxyCodeLine{00460\ \ \ \ \ \textcolor{keywordflow}{return}\ (first\ <\ size)\ ?\ first\ :\ size;}
\DoxyCodeLine{00461\ \ \ \}}
\DoxyCodeLine{00462\ \}}
\DoxyCodeLine{00463\ }
\DoxyCodeLine{00466\ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ Scalar,\ \textcolor{keyword}{typename}\ Index>}
\DoxyCodeLine{00467\ EIGEN\_DEVICE\_FUNC\ \textcolor{keyword}{inline}\ Index\ first\_default\_aligned(\textcolor{keyword}{const}\ Scalar*\ array,\ Index\ size)}
\DoxyCodeLine{00468\ \{}
\DoxyCodeLine{00469\ \ \ \textcolor{keyword}{typedef}\ \textcolor{keyword}{typename}\ packet\_traits<Scalar>::type\ DefaultPacketType;}
\DoxyCodeLine{00470\ \ \ \textcolor{keywordflow}{return}\ first\_aligned<unpacket\_traits<DefaultPacketType>::alignment>(array,\ size);}
\DoxyCodeLine{00471\ \}}
\DoxyCodeLine{00472\ }
\DoxyCodeLine{00475\ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ Index>\ }
\DoxyCodeLine{00476\ \textcolor{keyword}{inline}\ Index\ first\_multiple(Index\ size,\ Index\ base)}
\DoxyCodeLine{00477\ \{}
\DoxyCodeLine{00478\ \ \ \textcolor{keywordflow}{return}\ ((size+base-\/1)/base)*base;}
\DoxyCodeLine{00479\ \}}
\DoxyCodeLine{00480\ }
\DoxyCodeLine{00481\ \textcolor{comment}{//\ std::copy\ is\ much\ slower\ than\ memcpy,\ so\ let's\ introduce\ a\ smart\_copy\ which}}
\DoxyCodeLine{00482\ \textcolor{comment}{//\ use\ memcpy\ on\ trivial\ types,\ i.e.,\ on\ types\ that\ does\ not\ require\ an\ initialization\ ctor.}}
\DoxyCodeLine{00483\ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ T,\ \textcolor{keywordtype}{bool}\ UseMemcpy>\ \textcolor{keyword}{struct\ }\mbox{\hyperlink{struct_eigen_1_1internal_1_1smart__copy__helper}{smart\_copy\_helper}};}
\DoxyCodeLine{00484\ }
\DoxyCodeLine{00485\ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ T>\ EIGEN\_DEVICE\_FUNC\ \textcolor{keywordtype}{void}\ smart\_copy(\textcolor{keyword}{const}\ T*\ start,\ \textcolor{keyword}{const}\ T*\ end,\ T*\ target)}
\DoxyCodeLine{00486\ \{}
\DoxyCodeLine{00487\ \ \ \mbox{\hyperlink{struct_eigen_1_1internal_1_1smart__copy__helper}{smart\_copy\_helper<T,!NumTraits<T>::RequireInitialization}}>::run(start,\ end,\ target);}
\DoxyCodeLine{00488\ \}}
\DoxyCodeLine{00489\ }
\DoxyCodeLine{00490\ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ T>\ \textcolor{keyword}{struct\ }\mbox{\hyperlink{struct_eigen_1_1internal_1_1smart__copy__helper}{smart\_copy\_helper}}<T,true>\ \{}
\DoxyCodeLine{00491\ \ \ EIGEN\_DEVICE\_FUNC\ \textcolor{keyword}{static}\ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{void}\ run(\textcolor{keyword}{const}\ T*\ start,\ \textcolor{keyword}{const}\ T*\ end,\ T*\ target)}
\DoxyCodeLine{00492\ \ \ \{}
\DoxyCodeLine{00493\ \ \ \ \ IntPtr\ size\ =\ IntPtr(end)-\/IntPtr(start);}
\DoxyCodeLine{00494\ \ \ \ \ \textcolor{keywordflow}{if}(size==0)\ \textcolor{keywordflow}{return};}
\DoxyCodeLine{00495\ \ \ \ \ eigen\_internal\_assert(start!=0\ \&\&\ end!=0\ \&\&\ target!=0);}
\DoxyCodeLine{00496\ \ \ \ \ memcpy(target,\ start,\ size);}
\DoxyCodeLine{00497\ \ \ \}}
\DoxyCodeLine{00498\ \};}
\DoxyCodeLine{00499\ }
\DoxyCodeLine{00500\ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ T>\ \textcolor{keyword}{struct\ }\mbox{\hyperlink{struct_eigen_1_1internal_1_1smart__copy__helper}{smart\_copy\_helper}}<T,false>\ \{}
\DoxyCodeLine{00501\ \ \ EIGEN\_DEVICE\_FUNC\ \textcolor{keyword}{static}\ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{void}\ run(\textcolor{keyword}{const}\ T*\ start,\ \textcolor{keyword}{const}\ T*\ end,\ T*\ target)}
\DoxyCodeLine{00502\ \ \ \{\ std::copy(start,\ end,\ target);\ \}}
\DoxyCodeLine{00503\ \};}
\DoxyCodeLine{00504\ }
\DoxyCodeLine{00505\ \textcolor{comment}{//\ intelligent\ memmove.\ falls\ back\ to\ std::memmove\ for\ POD\ types,\ uses\ std::copy\ otherwise.\ }}
\DoxyCodeLine{00506\ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ T,\ \textcolor{keywordtype}{bool}\ UseMemmove>\ \textcolor{keyword}{struct\ }\mbox{\hyperlink{struct_eigen_1_1internal_1_1smart__memmove__helper}{smart\_memmove\_helper}};}
\DoxyCodeLine{00507\ }
\DoxyCodeLine{00508\ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ T>\ \textcolor{keywordtype}{void}\ smart\_memmove(\textcolor{keyword}{const}\ T*\ start,\ \textcolor{keyword}{const}\ T*\ end,\ T*\ target)}
\DoxyCodeLine{00509\ \{}
\DoxyCodeLine{00510\ \ \ \mbox{\hyperlink{struct_eigen_1_1internal_1_1smart__memmove__helper}{smart\_memmove\_helper<T,!NumTraits<T>::RequireInitialization}}>::run(start,\ end,\ target);}
\DoxyCodeLine{00511\ \}}
\DoxyCodeLine{00512\ }
\DoxyCodeLine{00513\ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ T>\ \textcolor{keyword}{struct\ }\mbox{\hyperlink{struct_eigen_1_1internal_1_1smart__memmove__helper}{smart\_memmove\_helper}}<T,true>\ \{}
\DoxyCodeLine{00514\ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{void}\ run(\textcolor{keyword}{const}\ T*\ start,\ \textcolor{keyword}{const}\ T*\ end,\ T*\ target)}
\DoxyCodeLine{00515\ \ \ \{}
\DoxyCodeLine{00516\ \ \ \ \ IntPtr\ size\ =\ IntPtr(end)-\/IntPtr(start);}
\DoxyCodeLine{00517\ \ \ \ \ \textcolor{keywordflow}{if}(size==0)\ \textcolor{keywordflow}{return};}
\DoxyCodeLine{00518\ \ \ \ \ eigen\_internal\_assert(start!=0\ \&\&\ end!=0\ \&\&\ target!=0);}
\DoxyCodeLine{00519\ \ \ \ \ std::memmove(target,\ start,\ size);}
\DoxyCodeLine{00520\ \ \ \}}
\DoxyCodeLine{00521\ \};}
\DoxyCodeLine{00522\ }
\DoxyCodeLine{00523\ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ T>\ \textcolor{keyword}{struct\ }\mbox{\hyperlink{struct_eigen_1_1internal_1_1smart__memmove__helper}{smart\_memmove\_helper}}<T,false>\ \{}
\DoxyCodeLine{00524\ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{void}\ run(\textcolor{keyword}{const}\ T*\ start,\ \textcolor{keyword}{const}\ T*\ end,\ T*\ target)}
\DoxyCodeLine{00525\ \ \ \{\ }
\DoxyCodeLine{00526\ \ \ \ \ \textcolor{keywordflow}{if}\ (UIntPtr(target)\ <\ UIntPtr(start))}
\DoxyCodeLine{00527\ \ \ \ \ \{}
\DoxyCodeLine{00528\ \ \ \ \ \ \ std::copy(start,\ end,\ target);}
\DoxyCodeLine{00529\ \ \ \ \ \}}
\DoxyCodeLine{00530\ \ \ \ \ \textcolor{keywordflow}{else}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ }
\DoxyCodeLine{00531\ \ \ \ \ \{}
\DoxyCodeLine{00532\ \ \ \ \ \ \ std::ptrdiff\_t\ count\ =\ (std::ptrdiff\_t(end)-\/std::ptrdiff\_t(start))\ /\ \textcolor{keyword}{sizeof}(T);}
\DoxyCodeLine{00533\ \ \ \ \ \ \ std::copy\_backward(start,\ end,\ target\ +\ count);\ }
\DoxyCodeLine{00534\ \ \ \ \ \}}
\DoxyCodeLine{00535\ \ \ \}}
\DoxyCodeLine{00536\ \};}
\DoxyCodeLine{00537\ }
\DoxyCodeLine{00538\ }
\DoxyCodeLine{00539\ \textcolor{comment}{/*****************************************************************************}}
\DoxyCodeLine{00540\ \textcolor{comment}{***\ Implementation\ of\ runtime\ stack\ allocation\ (falling\ back\ to\ malloc)\ \ \ \ ***}}
\DoxyCodeLine{00541\ \textcolor{comment}{*****************************************************************************/}}
\DoxyCodeLine{00542\ }
\DoxyCodeLine{00543\ \textcolor{comment}{//\ you\ can\ overwrite\ Eigen's\ default\ behavior\ regarding\ alloca\ by\ defining\ EIGEN\_ALLOCA}}
\DoxyCodeLine{00544\ \textcolor{comment}{//\ to\ the\ appropriate\ stack\ allocation\ function}}
\DoxyCodeLine{00545\ \textcolor{preprocessor}{\#ifndef\ EIGEN\_ALLOCA}}
\DoxyCodeLine{00546\ \textcolor{preprocessor}{\ \ \#if\ EIGEN\_OS\_LINUX\ ||\ EIGEN\_OS\_MAC\ ||\ (defined\ alloca)}}
\DoxyCodeLine{00547\ \textcolor{preprocessor}{\ \ \ \ \#define\ EIGEN\_ALLOCA\ alloca}}
\DoxyCodeLine{00548\ \textcolor{preprocessor}{\ \ \#elif\ EIGEN\_COMP\_MSVC}}
\DoxyCodeLine{00549\ \textcolor{preprocessor}{\ \ \ \ \#define\ EIGEN\_ALLOCA\ \_alloca}}
\DoxyCodeLine{00550\ \textcolor{preprocessor}{\ \ \#endif}}
\DoxyCodeLine{00551\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00552\ }
\DoxyCodeLine{00553\ \textcolor{comment}{//\ This\ helper\ class\ construct\ the\ allocated\ memory,\ and\ takes\ care\ of\ destructing\ and\ freeing\ the\ handled\ data}}
\DoxyCodeLine{00554\ \textcolor{comment}{//\ at\ destruction\ time.\ In\ practice\ this\ helper\ class\ is\ mainly\ useful\ to\ avoid\ memory\ leak\ in\ case\ of\ exceptions.}}
\DoxyCodeLine{00555\ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ T>\ \textcolor{keyword}{class\ }\mbox{\hyperlink{class_eigen_1_1internal_1_1aligned__stack__memory__handler}{aligned\_stack\_memory\_handler}}\ :\ \mbox{\hyperlink{class_eigen_1_1internal_1_1noncopyable}{noncopyable}}}
\DoxyCodeLine{00556\ \{}
\DoxyCodeLine{00557\ \ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{00558\ \ \ \ \ \textcolor{comment}{/*\ Creates\ a\ stack\_memory\_handler\ responsible\ for\ the\ buffer\ \(\backslash\)a\ ptr\ of\ size\ \(\backslash\)a\ size.}}
\DoxyCodeLine{00559\ \textcolor{comment}{\ \ \ \ \ *\ Note\ that\ \(\backslash\)a\ ptr\ can\ be\ 0\ regardless\ of\ the\ other\ parameters.}}
\DoxyCodeLine{00560\ \textcolor{comment}{\ \ \ \ \ *\ This\ constructor\ takes\ care\ of\ constructing/initializing\ the\ elements\ of\ the\ buffer\ if\ required\ by\ the\ scalar\ type\ T\ (see\ NumTraits<T>::RequireInitialization).}}
\DoxyCodeLine{00561\ \textcolor{comment}{\ \ \ \ \ *\ In\ this\ case,\ the\ buffer\ elements\ will\ also\ be\ destructed\ when\ this\ handler\ will\ be\ destructed.}}
\DoxyCodeLine{00562\ \textcolor{comment}{\ \ \ \ \ *\ Finally,\ if\ \(\backslash\)a\ dealloc\ is\ true,\ then\ the\ pointer\ \(\backslash\)a\ ptr\ is\ freed.}}
\DoxyCodeLine{00563\ \textcolor{comment}{\ \ \ \ \ **/}}
\DoxyCodeLine{00564\ \ \ \ \ \mbox{\hyperlink{class_eigen_1_1internal_1_1aligned__stack__memory__handler}{aligned\_stack\_memory\_handler}}(T*\ ptr,\ std::size\_t\ size,\ \textcolor{keywordtype}{bool}\ dealloc)}
\DoxyCodeLine{00565\ \ \ \ \ \ \ :\ m\_ptr(ptr),\ m\_size(size),\ m\_deallocate(dealloc)}
\DoxyCodeLine{00566\ \ \ \ \ \{}
\DoxyCodeLine{00567\ \ \ \ \ \ \ \textcolor{keywordflow}{if}(\mbox{\hyperlink{struct_eigen_1_1_num_traits}{NumTraits<T>::RequireInitialization}}\ \&\&\ m\_ptr)}
\DoxyCodeLine{00568\ \ \ \ \ \ \ \ \ Eigen::internal::construct\_elements\_of\_array(m\_ptr,\ size);}
\DoxyCodeLine{00569\ \ \ \ \ \}}
\DoxyCodeLine{00570\ \ \ \ \ \mbox{\hyperlink{class_eigen_1_1internal_1_1aligned__stack__memory__handler}{\string~aligned\_stack\_memory\_handler}}()}
\DoxyCodeLine{00571\ \ \ \ \ \{}
\DoxyCodeLine{00572\ \ \ \ \ \ \ \textcolor{keywordflow}{if}(\mbox{\hyperlink{struct_eigen_1_1_num_traits}{NumTraits<T>::RequireInitialization}}\ \&\&\ m\_ptr)}
\DoxyCodeLine{00573\ \ \ \ \ \ \ \ \ Eigen::internal::destruct\_elements\_of\_array<T>(m\_ptr,\ m\_size);}
\DoxyCodeLine{00574\ \ \ \ \ \ \ \textcolor{keywordflow}{if}(m\_deallocate)}
\DoxyCodeLine{00575\ \ \ \ \ \ \ \ \ Eigen::internal::aligned\_free(m\_ptr);}
\DoxyCodeLine{00576\ \ \ \ \ \}}
\DoxyCodeLine{00577\ \ \ \textcolor{keyword}{protected}:}
\DoxyCodeLine{00578\ \ \ \ \ T*\ m\_ptr;}
\DoxyCodeLine{00579\ \ \ \ \ std::size\_t\ m\_size;}
\DoxyCodeLine{00580\ \ \ \ \ \textcolor{keywordtype}{bool}\ m\_deallocate;}
\DoxyCodeLine{00581\ \};}
\DoxyCodeLine{00582\ }
\DoxyCodeLine{00583\ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ T>\ \textcolor{keyword}{class\ }\mbox{\hyperlink{class_eigen_1_1internal_1_1scoped__array}{scoped\_array}}\ :\ \mbox{\hyperlink{class_eigen_1_1internal_1_1noncopyable}{noncopyable}}}
\DoxyCodeLine{00584\ \{}
\DoxyCodeLine{00585\ \ \ T*\ m\_ptr;}
\DoxyCodeLine{00586\ \textcolor{keyword}{public}:}
\DoxyCodeLine{00587\ \ \ \textcolor{keyword}{explicit}\ \mbox{\hyperlink{class_eigen_1_1internal_1_1scoped__array}{scoped\_array}}(std::ptrdiff\_t\ size)}
\DoxyCodeLine{00588\ \ \ \{}
\DoxyCodeLine{00589\ \ \ \ \ m\_ptr\ =\ \textcolor{keyword}{new}\ T[size];}
\DoxyCodeLine{00590\ \ \ \}}
\DoxyCodeLine{00591\ \ \ \mbox{\hyperlink{class_eigen_1_1internal_1_1scoped__array}{\string~scoped\_array}}()}
\DoxyCodeLine{00592\ \ \ \{}
\DoxyCodeLine{00593\ \ \ \ \ \textcolor{keyword}{delete}[]\ m\_ptr;}
\DoxyCodeLine{00594\ \ \ \}}
\DoxyCodeLine{00595\ \ \ T\&\ operator[](std::ptrdiff\_t\ i)\ \{\ \textcolor{keywordflow}{return}\ m\_ptr[i];\ \}}
\DoxyCodeLine{00596\ \ \ \textcolor{keyword}{const}\ T\&\ operator[](std::ptrdiff\_t\ i)\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ m\_ptr[i];\ \}}
\DoxyCodeLine{00597\ \ \ T*\ \&ptr()\ \{\ \textcolor{keywordflow}{return}\ m\_ptr;\ \}}
\DoxyCodeLine{00598\ \ \ \textcolor{keyword}{const}\ T*\ ptr()\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ m\_ptr;\ \}}
\DoxyCodeLine{00599\ \ \ \textcolor{keyword}{operator}\ \textcolor{keyword}{const}\ T*()\ \textcolor{keyword}{const}\ \{\ \textcolor{keywordflow}{return}\ m\_ptr;\ \}}
\DoxyCodeLine{00600\ \};}
\DoxyCodeLine{00601\ }
\DoxyCodeLine{00602\ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ T>\ \textcolor{keywordtype}{void}\ swap(\mbox{\hyperlink{class_eigen_1_1internal_1_1scoped__array}{scoped\_array<T>}}\ \&a,\mbox{\hyperlink{class_eigen_1_1internal_1_1scoped__array}{scoped\_array<T>}}\ \&b)}
\DoxyCodeLine{00603\ \{}
\DoxyCodeLine{00604\ \ \ std::swap(a.ptr(),b.ptr());}
\DoxyCodeLine{00605\ \}}
\DoxyCodeLine{00606\ \ \ \ \ }
\DoxyCodeLine{00607\ \}\ \textcolor{comment}{//\ end\ namespace\ internal}}
\DoxyCodeLine{00608\ }
\DoxyCodeLine{00624\ \textcolor{preprocessor}{\#ifdef\ EIGEN\_ALLOCA}}
\DoxyCodeLine{00625\ \ \ }
\DoxyCodeLine{00626\ \textcolor{preprocessor}{\ \ \#if\ EIGEN\_DEFAULT\_ALIGN\_BYTES>0}}
\DoxyCodeLine{00627\ \ \ \ \ \textcolor{comment}{//\ We\ always\ manually\ re-\/align\ the\ result\ of\ EIGEN\_ALLOCA.}}
\DoxyCodeLine{00628\ \ \ \ \ \textcolor{comment}{//\ If\ alloca\ is\ already\ aligned,\ the\ compiler\ should\ be\ smart\ enough\ to\ optimize\ away\ the\ re-\/alignment.}}
\DoxyCodeLine{00629\ \textcolor{preprocessor}{\ \ \ \ \#define\ EIGEN\_ALIGNED\_ALLOCA(SIZE)\ reinterpret\_cast<void*>((internal::UIntPtr(EIGEN\_ALLOCA(SIZE+EIGEN\_DEFAULT\_ALIGN\_BYTES-\/1))\ +\ EIGEN\_DEFAULT\_ALIGN\_BYTES-\/1)\ \&\ \string~(std::size\_t(EIGEN\_DEFAULT\_ALIGN\_BYTES-\/1)))}}
\DoxyCodeLine{00630\ \textcolor{preprocessor}{\ \ \#else}}
\DoxyCodeLine{00631\ \textcolor{preprocessor}{\ \ \ \ \#define\ EIGEN\_ALIGNED\_ALLOCA(SIZE)\ EIGEN\_ALLOCA(SIZE)}}
\DoxyCodeLine{00632\ \textcolor{preprocessor}{\ \ \#endif}}
\DoxyCodeLine{00633\ }
\DoxyCodeLine{00634\ \textcolor{preprocessor}{\ \ \#define\ ei\_declare\_aligned\_stack\_constructed\_variable(TYPE,NAME,SIZE,BUFFER)\ \(\backslash\)}}
\DoxyCodeLine{00635\ \textcolor{preprocessor}{\ \ \ \ Eigen::internal::check\_size\_for\_overflow<TYPE>(SIZE);\ \(\backslash\)}}
\DoxyCodeLine{00636\ \textcolor{preprocessor}{\ \ \ \ TYPE*\ NAME\ =\ (BUFFER)!=0\ ?\ (BUFFER)\ \(\backslash\)}}
\DoxyCodeLine{00637\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ :\ reinterpret\_cast<TYPE*>(\ \(\backslash\)}}
\DoxyCodeLine{00638\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (sizeof(TYPE)*SIZE<=EIGEN\_STACK\_ALLOCATION\_LIMIT)\ ?\ EIGEN\_ALIGNED\_ALLOCA(sizeof(TYPE)*SIZE)\ \(\backslash\)}}
\DoxyCodeLine{00639\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ :\ Eigen::internal::aligned\_malloc(sizeof(TYPE)*SIZE)\ );\ \ \(\backslash\)}}
\DoxyCodeLine{00640\ \textcolor{preprocessor}{\ \ \ \ Eigen::internal::aligned\_stack\_memory\_handler<TYPE>\ EIGEN\_CAT(NAME,\_stack\_memory\_destructor)((BUFFER)==0\ ?\ NAME\ :\ 0,SIZE,sizeof(TYPE)*SIZE>EIGEN\_STACK\_ALLOCATION\_LIMIT)}}
\DoxyCodeLine{00641\ }
\DoxyCodeLine{00642\ \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{00643\ }
\DoxyCodeLine{00644\ \textcolor{preprocessor}{\ \ \#define\ ei\_declare\_aligned\_stack\_constructed\_variable(TYPE,NAME,SIZE,BUFFER)\ \(\backslash\)}}
\DoxyCodeLine{00645\ \textcolor{preprocessor}{\ \ \ \ Eigen::internal::check\_size\_for\_overflow<TYPE>(SIZE);\ \(\backslash\)}}
\DoxyCodeLine{00646\ \textcolor{preprocessor}{\ \ \ \ TYPE*\ NAME\ =\ (BUFFER)!=0\ ?\ BUFFER\ :\ reinterpret\_cast<TYPE*>(Eigen::internal::aligned\_malloc(sizeof(TYPE)*SIZE));\ \ \ \ \(\backslash\)}}
\DoxyCodeLine{00647\ \textcolor{preprocessor}{\ \ \ \ Eigen::internal::aligned\_stack\_memory\_handler<TYPE>\ EIGEN\_CAT(NAME,\_stack\_memory\_destructor)((BUFFER)==0\ ?\ NAME\ :\ 0,SIZE,true)}}
\DoxyCodeLine{00648\ \ \ \ \ }
\DoxyCodeLine{00649\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00650\ }
\DoxyCodeLine{00651\ }
\DoxyCodeLine{00652\ \textcolor{comment}{/*****************************************************************************}}
\DoxyCodeLine{00653\ \textcolor{comment}{***\ Implementation\ of\ EIGEN\_MAKE\_ALIGNED\_OPERATOR\_NEW\ [\_IF]\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ***}}
\DoxyCodeLine{00654\ \textcolor{comment}{*****************************************************************************/}}
\DoxyCodeLine{00655\ }
\DoxyCodeLine{00656\ \textcolor{preprocessor}{\#if\ EIGEN\_MAX\_ALIGN\_BYTES!=0}}
\DoxyCodeLine{00657\ \textcolor{preprocessor}{\ \ \#define\ EIGEN\_MAKE\_ALIGNED\_OPERATOR\_NEW\_NOTHROW(NeedsToAlign)\ \(\backslash\)}}
\DoxyCodeLine{00658\ \textcolor{preprocessor}{\ \ \ \ \ \ void*\ operator\ new(std::size\_t\ size,\ const\ std::nothrow\_t\&)\ EIGEN\_NO\_THROW\ \{\ \(\backslash\)}}
\DoxyCodeLine{00659\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ EIGEN\_TRY\ \{\ return\ Eigen::internal::conditional\_aligned\_malloc<NeedsToAlign>(size);\ \}\ \(\backslash\)}}
\DoxyCodeLine{00660\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ EIGEN\_CATCH\ (...)\ \{\ return\ 0;\ \}\ \(\backslash\)}}
\DoxyCodeLine{00661\ \textcolor{preprocessor}{\ \ \ \ \ \ \}}}
\DoxyCodeLine{00662\ \textcolor{preprocessor}{\ \ \#define\ EIGEN\_MAKE\_ALIGNED\_OPERATOR\_NEW\_IF(NeedsToAlign)\ \(\backslash\)}}
\DoxyCodeLine{00663\ \textcolor{preprocessor}{\ \ \ \ \ \ void\ *operator\ new(std::size\_t\ size)\ \{\ \(\backslash\)}}
\DoxyCodeLine{00664\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ return\ Eigen::internal::conditional\_aligned\_malloc<NeedsToAlign>(size);\ \(\backslash\)}}
\DoxyCodeLine{00665\ \textcolor{preprocessor}{\ \ \ \ \ \ \}\ \(\backslash\)}}
\DoxyCodeLine{00666\ \textcolor{preprocessor}{\ \ \ \ \ \ void\ *operator\ new[](std::size\_t\ size)\ \{\ \(\backslash\)}}
\DoxyCodeLine{00667\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ return\ Eigen::internal::conditional\_aligned\_malloc<NeedsToAlign>(size);\ \(\backslash\)}}
\DoxyCodeLine{00668\ \textcolor{preprocessor}{\ \ \ \ \ \ \}\ \(\backslash\)}}
\DoxyCodeLine{00669\ \textcolor{preprocessor}{\ \ \ \ \ \ void\ operator\ delete(void\ *\ ptr)\ EIGEN\_NO\_THROW\ \{\ Eigen::internal::conditional\_aligned\_free<NeedsToAlign>(ptr);\ \}\ \(\backslash\)}}
\DoxyCodeLine{00670\ \textcolor{preprocessor}{\ \ \ \ \ \ void\ operator\ delete[](void\ *\ ptr)\ EIGEN\_NO\_THROW\ \{\ Eigen::internal::conditional\_aligned\_free<NeedsToAlign>(ptr);\ \}\ \(\backslash\)}}
\DoxyCodeLine{00671\ \textcolor{preprocessor}{\ \ \ \ \ \ void\ operator\ delete(void\ *\ ptr,\ std::size\_t\ }\textcolor{comment}{/*\ sz\ */}\textcolor{preprocessor}{)\ EIGEN\_NO\_THROW\ \{\ Eigen::internal::conditional\_aligned\_free<NeedsToAlign>(ptr);\ \}\ \(\backslash\)}}
\DoxyCodeLine{00672\ \textcolor{preprocessor}{\ \ \ \ \ \ void\ operator\ delete[](void\ *\ ptr,\ std::size\_t\ }\textcolor{comment}{/*\ sz\ */}\textcolor{preprocessor}{)\ EIGEN\_NO\_THROW\ \{\ Eigen::internal::conditional\_aligned\_free<NeedsToAlign>(ptr);\ \}\ \(\backslash\)}}
\DoxyCodeLine{00673\ \textcolor{preprocessor}{\ \ \ \ \ \ }\textcolor{comment}{/*\ in-\/place\ new\ and\ delete.\ since\ (at\ least\ afaik)\ there\ is\ no\ actual\ \ \ */}\textcolor{preprocessor}{\ \(\backslash\)}}
\DoxyCodeLine{00674\ \textcolor{preprocessor}{\ \ \ \ \ \ }\textcolor{comment}{/*\ memory\ allocated\ we\ can\ safely\ let\ the\ default\ implementation\ handle\ */}\textcolor{preprocessor}{\ \(\backslash\)}}
\DoxyCodeLine{00675\ \textcolor{preprocessor}{\ \ \ \ \ \ }\textcolor{comment}{/*\ this\ particular\ case.\ */}\textcolor{preprocessor}{\ \(\backslash\)}}
\DoxyCodeLine{00676\ \textcolor{preprocessor}{\ \ \ \ \ \ static\ void\ *operator\ new(std::size\_t\ size,\ void\ *ptr)\ \{\ return\ ::operator\ new(size,ptr);\ \}\ \(\backslash\)}}
\DoxyCodeLine{00677\ \textcolor{preprocessor}{\ \ \ \ \ \ static\ void\ *operator\ new[](std::size\_t\ size,\ void*\ ptr)\ \{\ return\ ::operator\ new[](size,ptr);\ \}\ \(\backslash\)}}
\DoxyCodeLine{00678\ \textcolor{preprocessor}{\ \ \ \ \ \ void\ operator\ delete(void\ *\ memory,\ void\ *ptr)\ EIGEN\_NO\_THROW\ \{\ return\ ::operator\ delete(memory,ptr);\ \}\ \(\backslash\)}}
\DoxyCodeLine{00679\ \textcolor{preprocessor}{\ \ \ \ \ \ void\ operator\ delete[](void\ *\ memory,\ void\ *ptr)\ EIGEN\_NO\_THROW\ \{\ return\ ::operator\ delete[](memory,ptr);\ \}\ \(\backslash\)}}
\DoxyCodeLine{00680\ \textcolor{preprocessor}{\ \ \ \ \ \ }\textcolor{comment}{/*\ nothrow-\/new\ (returns\ zero\ instead\ of\ std::bad\_alloc)\ */}\textcolor{preprocessor}{\ \(\backslash\)}}
\DoxyCodeLine{00681\ \textcolor{preprocessor}{\ \ \ \ \ \ EIGEN\_MAKE\_ALIGNED\_OPERATOR\_NEW\_NOTHROW(NeedsToAlign)\ \(\backslash\)}}
\DoxyCodeLine{00682\ \textcolor{preprocessor}{\ \ \ \ \ \ void\ operator\ delete(void\ *ptr,\ const\ std::nothrow\_t\&)\ EIGEN\_NO\_THROW\ \{\ \(\backslash\)}}
\DoxyCodeLine{00683\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ Eigen::internal::conditional\_aligned\_free<NeedsToAlign>(ptr);\ \(\backslash\)}}
\DoxyCodeLine{00684\ \textcolor{preprocessor}{\ \ \ \ \ \ \}\ \(\backslash\)}}
\DoxyCodeLine{00685\ \textcolor{preprocessor}{\ \ \ \ \ \ typedef\ void\ eigen\_aligned\_operator\_new\_marker\_type;}}
\DoxyCodeLine{00686\ \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{00687\ \textcolor{preprocessor}{\ \ \#define\ EIGEN\_MAKE\_ALIGNED\_OPERATOR\_NEW\_IF(NeedsToAlign)}}
\DoxyCodeLine{00688\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00689\ }
\DoxyCodeLine{00690\ \textcolor{preprocessor}{\#define\ EIGEN\_MAKE\_ALIGNED\_OPERATOR\_NEW\ EIGEN\_MAKE\_ALIGNED\_OPERATOR\_NEW\_IF(true)}}
\DoxyCodeLine{00691\ \textcolor{preprocessor}{\#define\ EIGEN\_MAKE\_ALIGNED\_OPERATOR\_NEW\_IF\_VECTORIZABLE\_FIXED\_SIZE(Scalar,Size)\ \(\backslash\)}}
\DoxyCodeLine{00692\ \textcolor{preprocessor}{\ \ EIGEN\_MAKE\_ALIGNED\_OPERATOR\_NEW\_IF(bool(((Size)!=Eigen::Dynamic)\ \&\&\ ((sizeof(Scalar)*(Size))\%EIGEN\_MAX\_ALIGN\_BYTES==0)))}}
\DoxyCodeLine{00693\ }
\DoxyCodeLine{00694\ \textcolor{comment}{/****************************************************************************/}}
\DoxyCodeLine{00695\ }
\DoxyCodeLine{00712\ \textcolor{keyword}{template}<\textcolor{keyword}{class}\ T>}
\DoxyCodeLine{00713\ \textcolor{keyword}{class\ }\mbox{\hyperlink{class_eigen_1_1aligned__allocator}{aligned\_allocator}}\ :\ \textcolor{keyword}{public}\ std::allocator<T>}
\DoxyCodeLine{00714\ \{}
\DoxyCodeLine{00715\ \textcolor{keyword}{public}:}
\DoxyCodeLine{00716\ \ \ \textcolor{keyword}{typedef}\ std::size\_t\ \ \ \ \ size\_type;}
\DoxyCodeLine{00717\ \ \ \textcolor{keyword}{typedef}\ std::ptrdiff\_t\ \ difference\_type;}
\DoxyCodeLine{00718\ \ \ \textcolor{keyword}{typedef}\ T*\ \ \ \ \ \ \ \ \ \ \ \ \ \ pointer;}
\DoxyCodeLine{00719\ \ \ \textcolor{keyword}{typedef}\ \textcolor{keyword}{const}\ T*\ \ \ \ \ \ \ \ const\_pointer;}
\DoxyCodeLine{00720\ \ \ \textcolor{keyword}{typedef}\ T\&\ \ \ \ \ \ \ \ \ \ \ \ \ \ reference;}
\DoxyCodeLine{00721\ \ \ \textcolor{keyword}{typedef}\ \textcolor{keyword}{const}\ T\&\ \ \ \ \ \ \ \ const\_reference;}
\DoxyCodeLine{00722\ \ \ \textcolor{keyword}{typedef}\ T\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ value\_type;}
\DoxyCodeLine{00723\ }
\DoxyCodeLine{00724\ \ \ \textcolor{keyword}{template}<\textcolor{keyword}{class}\ U>}
\DoxyCodeLine{00725\ \ \ \textcolor{keyword}{struct\ }\mbox{\hyperlink{struct_eigen_1_1aligned__allocator_1_1rebind}{rebind}}}
\DoxyCodeLine{00726\ \ \ \{}
\DoxyCodeLine{00727\ \ \ \ \ \textcolor{keyword}{typedef}\ \mbox{\hyperlink{class_eigen_1_1aligned__allocator}{aligned\_allocator<U>}}\ \mbox{\hyperlink{class_eigen_1_1aligned__allocator}{other}};}
\DoxyCodeLine{00728\ \ \ \};}
\DoxyCodeLine{00729\ }
\DoxyCodeLine{00730\ \ \ \mbox{\hyperlink{class_eigen_1_1aligned__allocator}{aligned\_allocator}}()\ :\ std::allocator<T>()\ \{\}}
\DoxyCodeLine{00731\ }
\DoxyCodeLine{00732\ \ \ \mbox{\hyperlink{class_eigen_1_1aligned__allocator}{aligned\_allocator}}(\textcolor{keyword}{const}\ \mbox{\hyperlink{class_eigen_1_1aligned__allocator}{aligned\_allocator}}\&\ other)\ :\ std::allocator<T>(other)\ \{\}}
\DoxyCodeLine{00733\ }
\DoxyCodeLine{00734\ \ \ \textcolor{keyword}{template}<\textcolor{keyword}{class}\ U>}
\DoxyCodeLine{00735\ \ \ aligned\_allocator(\textcolor{keyword}{const}\ aligned\_allocator<U>\&\ other)\ :\ std::allocator<T>(other)\ \{\}}
\DoxyCodeLine{00736\ }
\DoxyCodeLine{00737\ \ \ \string~aligned\_allocator()\ \{\}}
\DoxyCodeLine{00738\ }
\DoxyCodeLine{00739\ \ \ pointer\ allocate(size\_type\ num,\ \textcolor{keyword}{const}\ \textcolor{keywordtype}{void}*\ \textcolor{comment}{/*hint*/}\ =\ 0)}
\DoxyCodeLine{00740\ \ \ \{}
\DoxyCodeLine{00741\ \ \ \ \ internal::check\_size\_for\_overflow<T>(num);}
\DoxyCodeLine{00742\ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{static\_cast<}pointer\textcolor{keyword}{>}(\ internal::aligned\_malloc(num\ *\ \textcolor{keyword}{sizeof}(T))\ );}
\DoxyCodeLine{00743\ \ \ \}}
\DoxyCodeLine{00744\ }
\DoxyCodeLine{00745\ \ \ \textcolor{keywordtype}{void}\ deallocate(pointer\ p,\ size\_type\ \textcolor{comment}{/*num*/})}
\DoxyCodeLine{00746\ \ \ \{}
\DoxyCodeLine{00747\ \ \ \ \ internal::aligned\_free(p);}
\DoxyCodeLine{00748\ \ \ \}}
\DoxyCodeLine{00749\ \};}
\DoxyCodeLine{00750\ }
\DoxyCodeLine{00751\ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/\ Cache\ sizes\ -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{00752\ }
\DoxyCodeLine{00753\ \textcolor{preprocessor}{\#if\ !defined(EIGEN\_NO\_CPUID)}}
\DoxyCodeLine{00754\ \textcolor{preprocessor}{\#\ \ if\ EIGEN\_COMP\_GNUC\ \&\&\ EIGEN\_ARCH\_i386\_OR\_x86\_64}}
\DoxyCodeLine{00755\ \textcolor{preprocessor}{\#\ \ \ \ if\ defined(\_\_PIC\_\_)\ \&\&\ EIGEN\_ARCH\_i386}}
\DoxyCodeLine{00756\ \ \ \ \ \ \ \ \textcolor{comment}{//\ Case\ for\ x86\ with\ PIC}}
\DoxyCodeLine{00757\ \textcolor{preprocessor}{\#\ \ \ \ \ \ define\ EIGEN\_CPUID(abcd,func,id)\ \(\backslash\)}}
\DoxyCodeLine{00758\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ \ \_\_asm\_\_\ \_\_volatile\_\_\ ("{}xchgl\ \%\%ebx,\ \%k1;cpuid;\ xchgl\ \%\%ebx,\%k1"{}:\ "{}=a"{}\ (abcd[0]),\ "{}=\&r"{}\ (abcd[1]),\ "{}=c"{}\ (abcd[2]),\ "{}=d"{}\ (abcd[3])\ :\ "{}a"{}\ (func),\ "{}c"{}\ (id));}}
\DoxyCodeLine{00759\ \textcolor{preprocessor}{\#\ \ \ \ elif\ defined(\_\_PIC\_\_)\ \&\&\ EIGEN\_ARCH\_x86\_64}}
\DoxyCodeLine{00760\ \ \ \ \ \ \ \ \textcolor{comment}{//\ Case\ for\ x64\ with\ PIC.\ In\ theory\ this\ is\ only\ a\ problem\ with\ recent\ gcc\ and\ with\ medium\ or\ large\ code\ model,\ not\ with\ the\ default\ small\ code\ model.}}
\DoxyCodeLine{00761\ \ \ \ \ \ \ \ \textcolor{comment}{//\ However,\ we\ cannot\ detect\ which\ code\ model\ is\ used,\ and\ the\ xchg\ overhead\ is\ negligible\ anyway.}}
\DoxyCodeLine{00762\ \textcolor{preprocessor}{\#\ \ \ \ \ \ define\ EIGEN\_CPUID(abcd,func,id)\ \(\backslash\)}}
\DoxyCodeLine{00763\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ \_\_asm\_\_\ \_\_volatile\_\_\ ("{}xchg\{q\}\(\backslash\)t\{\%\%\}rbx,\ \%q1;\ cpuid;\ xchg\{q\}\(\backslash\)t\{\%\%\}rbx,\ \%q1"{}:\ "{}=a"{}\ (abcd[0]),\ "{}=\&r"{}\ (abcd[1]),\ "{}=c"{}\ (abcd[2]),\ "{}=d"{}\ (abcd[3])\ :\ "{}0"{}\ (func),\ "{}2"{}\ (id));}}
\DoxyCodeLine{00764\ \textcolor{preprocessor}{\#\ \ \ \ else}}
\DoxyCodeLine{00765\ \ \ \ \ \ \ \ \textcolor{comment}{//\ Case\ for\ x86\_64\ or\ x86\ w/o\ PIC}}
\DoxyCodeLine{00766\ \textcolor{preprocessor}{\#\ \ \ \ \ \ define\ EIGEN\_CPUID(abcd,func,id)\ \(\backslash\)}}
\DoxyCodeLine{00767\ \textcolor{preprocessor}{\ \ \ \ \ \ \ \ \ \_\_asm\_\_\ \_\_volatile\_\_\ ("{}cpuid"{}:\ "{}=a"{}\ (abcd[0]),\ "{}=b"{}\ (abcd[1]),\ "{}=c"{}\ (abcd[2]),\ "{}=d"{}\ (abcd[3])\ :\ "{}0"{}\ (func),\ "{}2"{}\ (id)\ );}}
\DoxyCodeLine{00768\ \textcolor{preprocessor}{\#\ \ \ \ endif}}
\DoxyCodeLine{00769\ \textcolor{preprocessor}{\#\ \ elif\ EIGEN\_COMP\_MSVC}}
\DoxyCodeLine{00770\ \textcolor{preprocessor}{\#\ \ \ \ if\ (EIGEN\_COMP\_MSVC\ >\ 1500)\ \&\&\ EIGEN\_ARCH\_i386\_OR\_x86\_64}}
\DoxyCodeLine{00771\ \textcolor{preprocessor}{\#\ \ \ \ \ \ define\ EIGEN\_CPUID(abcd,func,id)\ \_\_cpuidex((int*)abcd,func,id)}}
\DoxyCodeLine{00772\ \textcolor{preprocessor}{\#\ \ \ \ endif}}
\DoxyCodeLine{00773\ \textcolor{preprocessor}{\#\ \ endif}}
\DoxyCodeLine{00774\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00775\ }
\DoxyCodeLine{00776\ \textcolor{keyword}{namespace\ }internal\ \{}
\DoxyCodeLine{00777\ }
\DoxyCodeLine{00778\ \textcolor{preprocessor}{\#ifdef\ EIGEN\_CPUID}}
\DoxyCodeLine{00779\ }
\DoxyCodeLine{00780\ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{bool}\ cpuid\_is\_vendor(\textcolor{keywordtype}{int}\ abcd[4],\ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ vendor[3])}
\DoxyCodeLine{00781\ \{}
\DoxyCodeLine{00782\ \ \ \textcolor{keywordflow}{return}\ abcd[1]==vendor[0]\ \&\&\ abcd[3]==vendor[1]\ \&\&\ abcd[2]==vendor[2];}
\DoxyCodeLine{00783\ \}}
\DoxyCodeLine{00784\ }
\DoxyCodeLine{00785\ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{void}\ queryCacheSizes\_intel\_direct(\textcolor{keywordtype}{int}\&\ l1,\ \textcolor{keywordtype}{int}\&\ l2,\ \textcolor{keywordtype}{int}\&\ l3)}
\DoxyCodeLine{00786\ \{}
\DoxyCodeLine{00787\ \ \ \textcolor{keywordtype}{int}\ abcd[4];}
\DoxyCodeLine{00788\ \ \ l1\ =\ l2\ =\ l3\ =\ 0;}
\DoxyCodeLine{00789\ \ \ \textcolor{keywordtype}{int}\ cache\_id\ =\ 0;}
\DoxyCodeLine{00790\ \ \ \textcolor{keywordtype}{int}\ cache\_type\ =\ 0;}
\DoxyCodeLine{00791\ \ \ \textcolor{keywordflow}{do}\ \{}
\DoxyCodeLine{00792\ \ \ \ \ abcd[0]\ =\ abcd[1]\ =\ abcd[2]\ =\ abcd[3]\ =\ 0;}
\DoxyCodeLine{00793\ \ \ \ \ EIGEN\_CPUID(abcd,0x4,cache\_id);}
\DoxyCodeLine{00794\ \ \ \ \ cache\_type\ \ =\ (abcd[0]\ \&\ 0x0F)\ >>\ 0;}
\DoxyCodeLine{00795\ \ \ \ \ \textcolor{keywordflow}{if}(cache\_type==1||cache\_type==3)\ \textcolor{comment}{//\ data\ or\ unified\ cache}}
\DoxyCodeLine{00796\ \ \ \ \ \{}
\DoxyCodeLine{00797\ \ \ \ \ \ \ \textcolor{keywordtype}{int}\ cache\_level\ =\ (abcd[0]\ \&\ 0xE0)\ >>\ 5;\ \ \textcolor{comment}{//\ A[7:5]}}
\DoxyCodeLine{00798\ \ \ \ \ \ \ \textcolor{keywordtype}{int}\ ways\ \ \ \ \ \ \ \ =\ (abcd[1]\ \&\ 0xFFC00000)\ >>\ 22;\ \textcolor{comment}{//\ B[31:22]}}
\DoxyCodeLine{00799\ \ \ \ \ \ \ \textcolor{keywordtype}{int}\ partitions\ \ =\ (abcd[1]\ \&\ 0x003FF000)\ >>\ 12;\ \textcolor{comment}{//\ B[21:12]}}
\DoxyCodeLine{00800\ \ \ \ \ \ \ \textcolor{keywordtype}{int}\ line\_size\ \ \ =\ (abcd[1]\ \&\ 0x00000FFF)\ >>\ \ 0;\ \textcolor{comment}{//\ B[11:0]}}
\DoxyCodeLine{00801\ \ \ \ \ \ \ \textcolor{keywordtype}{int}\ sets\ \ \ \ \ \ \ \ =\ (abcd[2]);\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ C[31:0]}}
\DoxyCodeLine{00802\ }
\DoxyCodeLine{00803\ \ \ \ \ \ \ \textcolor{keywordtype}{int}\ cache\_size\ =\ (ways+1)\ *\ (partitions+1)\ *\ (line\_size+1)\ *\ (sets+1);}
\DoxyCodeLine{00804\ }
\DoxyCodeLine{00805\ \ \ \ \ \ \ \textcolor{keywordflow}{switch}(cache\_level)}
\DoxyCodeLine{00806\ \ \ \ \ \ \ \{}
\DoxyCodeLine{00807\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ 1:\ l1\ =\ cache\_size;\ \textcolor{keywordflow}{break};}
\DoxyCodeLine{00808\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ 2:\ l2\ =\ cache\_size;\ \textcolor{keywordflow}{break};}
\DoxyCodeLine{00809\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ 3:\ l3\ =\ cache\_size;\ \textcolor{keywordflow}{break};}
\DoxyCodeLine{00810\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{default}:\ \textcolor{keywordflow}{break};}
\DoxyCodeLine{00811\ \ \ \ \ \ \ \}}
\DoxyCodeLine{00812\ \ \ \ \ \}}
\DoxyCodeLine{00813\ \ \ \ \ cache\_id++;}
\DoxyCodeLine{00814\ \ \ \}\ \textcolor{keywordflow}{while}(cache\_type>0\ \&\&\ cache\_id<16);}
\DoxyCodeLine{00815\ \}}
\DoxyCodeLine{00816\ }
\DoxyCodeLine{00817\ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{void}\ queryCacheSizes\_intel\_codes(\textcolor{keywordtype}{int}\&\ l1,\ \textcolor{keywordtype}{int}\&\ l2,\ \textcolor{keywordtype}{int}\&\ l3)}
\DoxyCodeLine{00818\ \{}
\DoxyCodeLine{00819\ \ \ \textcolor{keywordtype}{int}\ abcd[4];}
\DoxyCodeLine{00820\ \ \ abcd[0]\ =\ abcd[1]\ =\ abcd[2]\ =\ abcd[3]\ =\ 0;}
\DoxyCodeLine{00821\ \ \ l1\ =\ l2\ =\ l3\ =\ 0;}
\DoxyCodeLine{00822\ \ \ EIGEN\_CPUID(abcd,0x00000002,0);}
\DoxyCodeLine{00823\ \ \ \textcolor{keywordtype}{unsigned}\ \textcolor{keywordtype}{char}\ *\ bytes\ =\ \textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{unsigned}\ \textcolor{keywordtype}{char}\ *\textcolor{keyword}{>}(abcd)+2;}
\DoxyCodeLine{00824\ \ \ \textcolor{keywordtype}{bool}\ check\_for\_p2\_core2\ =\ \textcolor{keyword}{false};}
\DoxyCodeLine{00825\ \ \ \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int}\ i=0;\ i<14;\ ++i)}
\DoxyCodeLine{00826\ \ \ \{}
\DoxyCodeLine{00827\ \ \ \ \ \textcolor{keywordflow}{switch}(bytes[i])}
\DoxyCodeLine{00828\ \ \ \ \ \{}
\DoxyCodeLine{00829\ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ 0x0A:\ l1\ =\ 8;\ \textcolor{keywordflow}{break};\ \ \ \textcolor{comment}{//\ 0Ah\ \ \ data\ L1\ cache,\ 8\ KB,\ 2\ ways,\ 32\ byte\ lines}}
\DoxyCodeLine{00830\ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ 0x0C:\ l1\ =\ 16;\ \textcolor{keywordflow}{break};\ \ \textcolor{comment}{//\ 0Ch\ \ \ data\ L1\ cache,\ 16\ KB,\ 4\ ways,\ 32\ byte\ lines}}
\DoxyCodeLine{00831\ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ 0x0E:\ l1\ =\ 24;\ \textcolor{keywordflow}{break};\ \ \textcolor{comment}{//\ 0Eh\ \ \ data\ L1\ cache,\ 24\ KB,\ 6\ ways,\ 64\ byte\ lines}}
\DoxyCodeLine{00832\ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ 0x10:\ l1\ =\ 16;\ \textcolor{keywordflow}{break};\ \ \textcolor{comment}{//\ 10h\ \ \ data\ L1\ cache,\ 16\ KB,\ 4\ ways,\ 32\ byte\ lines\ (IA-\/64)}}
\DoxyCodeLine{00833\ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ 0x15:\ l1\ =\ 16;\ \textcolor{keywordflow}{break};\ \ \textcolor{comment}{//\ 15h\ \ \ code\ L1\ cache,\ 16\ KB,\ 4\ ways,\ 32\ byte\ lines\ (IA-\/64)}}
\DoxyCodeLine{00834\ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ 0x2C:\ l1\ =\ 32;\ \textcolor{keywordflow}{break};\ \ \textcolor{comment}{//\ 2Ch\ \ \ data\ L1\ cache,\ 32\ KB,\ 8\ ways,\ 64\ byte\ lines}}
\DoxyCodeLine{00835\ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ 0x30:\ l1\ =\ 32;\ \textcolor{keywordflow}{break};\ \ \textcolor{comment}{//\ 30h\ \ \ code\ L1\ cache,\ 32\ KB,\ 8\ ways,\ 64\ byte\ lines}}
\DoxyCodeLine{00836\ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ 0x60:\ l1\ =\ 16;\ \textcolor{keywordflow}{break};\ \ \textcolor{comment}{//\ 60h\ \ \ data\ L1\ cache,\ 16\ KB,\ 8\ ways,\ 64\ byte\ lines,\ sectored}}
\DoxyCodeLine{00837\ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ 0x66:\ l1\ =\ 8;\ \textcolor{keywordflow}{break};\ \ \ \textcolor{comment}{//\ 66h\ \ \ data\ L1\ cache,\ 8\ KB,\ 4\ ways,\ 64\ byte\ lines,\ sectored}}
\DoxyCodeLine{00838\ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ 0x67:\ l1\ =\ 16;\ \textcolor{keywordflow}{break};\ \ \textcolor{comment}{//\ 67h\ \ \ data\ L1\ cache,\ 16\ KB,\ 4\ ways,\ 64\ byte\ lines,\ sectored}}
\DoxyCodeLine{00839\ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ 0x68:\ l1\ =\ 32;\ \textcolor{keywordflow}{break};\ \ \textcolor{comment}{//\ 68h\ \ \ data\ L1\ cache,\ 32\ KB,\ 4\ ways,\ 64\ byte\ lines,\ sectored}}
\DoxyCodeLine{00840\ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ 0x1A:\ l2\ =\ 96;\ \textcolor{keywordflow}{break};\ \ \ \textcolor{comment}{//\ code\ and\ data\ L2\ cache,\ 96\ KB,\ 6\ ways,\ 64\ byte\ lines\ (IA-\/64)}}
\DoxyCodeLine{00841\ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ 0x22:\ l3\ =\ 512;\ \textcolor{keywordflow}{break};\ \ \ \textcolor{comment}{//\ code\ and\ data\ L3\ cache,\ 512\ KB,\ 4\ ways\ (!),\ 64\ byte\ lines,\ dual-\/sectored}}
\DoxyCodeLine{00842\ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ 0x23:\ l3\ =\ 1024;\ \textcolor{keywordflow}{break};\ \ \ \textcolor{comment}{//\ code\ and\ data\ L3\ cache,\ 1024\ KB,\ 8\ ways,\ 64\ byte\ lines,\ dual-\/sectored}}
\DoxyCodeLine{00843\ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ 0x25:\ l3\ =\ 2048;\ \textcolor{keywordflow}{break};\ \ \ \textcolor{comment}{//\ code\ and\ data\ L3\ cache,\ 2048\ KB,\ 8\ ways,\ 64\ byte\ lines,\ dual-\/sectored}}
\DoxyCodeLine{00844\ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ 0x29:\ l3\ =\ 4096;\ \textcolor{keywordflow}{break};\ \ \ \textcolor{comment}{//\ code\ and\ data\ L3\ cache,\ 4096\ KB,\ 8\ ways,\ 64\ byte\ lines,\ dual-\/sectored}}
\DoxyCodeLine{00845\ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ 0x39:\ l2\ =\ 128;\ \textcolor{keywordflow}{break};\ \ \ \textcolor{comment}{//\ code\ and\ data\ L2\ cache,\ 128\ KB,\ 4\ ways,\ 64\ byte\ lines,\ sectored}}
\DoxyCodeLine{00846\ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ 0x3A:\ l2\ =\ 192;\ \textcolor{keywordflow}{break};\ \ \ \textcolor{comment}{//\ code\ and\ data\ L2\ cache,\ 192\ KB,\ 6\ ways,\ 64\ byte\ lines,\ sectored}}
\DoxyCodeLine{00847\ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ 0x3B:\ l2\ =\ 128;\ \textcolor{keywordflow}{break};\ \ \ \textcolor{comment}{//\ code\ and\ data\ L2\ cache,\ 128\ KB,\ 2\ ways,\ 64\ byte\ lines,\ sectored}}
\DoxyCodeLine{00848\ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ 0x3C:\ l2\ =\ 256;\ \textcolor{keywordflow}{break};\ \ \ \textcolor{comment}{//\ code\ and\ data\ L2\ cache,\ 256\ KB,\ 4\ ways,\ 64\ byte\ lines,\ sectored}}
\DoxyCodeLine{00849\ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ 0x3D:\ l2\ =\ 384;\ \textcolor{keywordflow}{break};\ \ \ \textcolor{comment}{//\ code\ and\ data\ L2\ cache,\ 384\ KB,\ 6\ ways,\ 64\ byte\ lines,\ sectored}}
\DoxyCodeLine{00850\ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ 0x3E:\ l2\ =\ 512;\ \textcolor{keywordflow}{break};\ \ \ \textcolor{comment}{//\ code\ and\ data\ L2\ cache,\ 512\ KB,\ 4\ ways,\ 64\ byte\ lines,\ sectored}}
\DoxyCodeLine{00851\ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ 0x40:\ l2\ =\ 0;\ \textcolor{keywordflow}{break};\ \ \ \textcolor{comment}{//\ no\ integrated\ L2\ cache\ (P6\ core)\ or\ L3\ cache\ (P4\ core)}}
\DoxyCodeLine{00852\ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ 0x41:\ l2\ =\ 128;\ \textcolor{keywordflow}{break};\ \ \ \textcolor{comment}{//\ code\ and\ data\ L2\ cache,\ 128\ KB,\ 4\ ways,\ 32\ byte\ lines}}
\DoxyCodeLine{00853\ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ 0x42:\ l2\ =\ 256;\ \textcolor{keywordflow}{break};\ \ \ \textcolor{comment}{//\ code\ and\ data\ L2\ cache,\ 256\ KB,\ 4\ ways,\ 32\ byte\ lines}}
\DoxyCodeLine{00854\ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ 0x43:\ l2\ =\ 512;\ \textcolor{keywordflow}{break};\ \ \ \textcolor{comment}{//\ code\ and\ data\ L2\ cache,\ 512\ KB,\ 4\ ways,\ 32\ byte\ lines}}
\DoxyCodeLine{00855\ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ 0x44:\ l2\ =\ 1024;\ \textcolor{keywordflow}{break};\ \ \ \textcolor{comment}{//\ code\ and\ data\ L2\ cache,\ 1024\ KB,\ 4\ ways,\ 32\ byte\ lines}}
\DoxyCodeLine{00856\ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ 0x45:\ l2\ =\ 2048;\ \textcolor{keywordflow}{break};\ \ \ \textcolor{comment}{//\ code\ and\ data\ L2\ cache,\ 2048\ KB,\ 4\ ways,\ 32\ byte\ lines}}
\DoxyCodeLine{00857\ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ 0x46:\ l3\ =\ 4096;\ \textcolor{keywordflow}{break};\ \ \ \textcolor{comment}{//\ code\ and\ data\ L3\ cache,\ 4096\ KB,\ 4\ ways,\ 64\ byte\ lines}}
\DoxyCodeLine{00858\ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ 0x47:\ l3\ =\ 8192;\ \textcolor{keywordflow}{break};\ \ \ \textcolor{comment}{//\ code\ and\ data\ L3\ cache,\ 8192\ KB,\ 8\ ways,\ 64\ byte\ lines}}
\DoxyCodeLine{00859\ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ 0x48:\ l2\ =\ 3072;\ \textcolor{keywordflow}{break};\ \ \ \textcolor{comment}{//\ code\ and\ data\ L2\ cache,\ 3072\ KB,\ 12\ ways,\ 64\ byte\ lines}}
\DoxyCodeLine{00860\ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ 0x49:\ \textcolor{keywordflow}{if}(l2!=0)\ l3\ =\ 4096;\ \textcolor{keywordflow}{else}\ \{check\_for\_p2\_core2=\textcolor{keyword}{true};\ l3\ =\ l2\ =\ 4096;\}\ \textcolor{keywordflow}{break};\textcolor{comment}{//\ code\ and\ data\ L3\ cache,\ 4096\ KB,\ 16\ ways,\ 64\ byte\ lines\ (P4)\ or\ L2\ for\ core2}}
\DoxyCodeLine{00861\ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ 0x4A:\ l3\ =\ 6144;\ \textcolor{keywordflow}{break};\ \ \ \textcolor{comment}{//\ code\ and\ data\ L3\ cache,\ 6144\ KB,\ 12\ ways,\ 64\ byte\ lines}}
\DoxyCodeLine{00862\ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ 0x4B:\ l3\ =\ 8192;\ \textcolor{keywordflow}{break};\ \ \ \textcolor{comment}{//\ code\ and\ data\ L3\ cache,\ 8192\ KB,\ 16\ ways,\ 64\ byte\ lines}}
\DoxyCodeLine{00863\ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ 0x4C:\ l3\ =\ 12288;\ \textcolor{keywordflow}{break};\ \ \ \textcolor{comment}{//\ code\ and\ data\ L3\ cache,\ 12288\ KB,\ 12\ ways,\ 64\ byte\ lines}}
\DoxyCodeLine{00864\ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ 0x4D:\ l3\ =\ 16384;\ \textcolor{keywordflow}{break};\ \ \ \textcolor{comment}{//\ code\ and\ data\ L3\ cache,\ 16384\ KB,\ 16\ ways,\ 64\ byte\ lines}}
\DoxyCodeLine{00865\ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ 0x4E:\ l2\ =\ 6144;\ \textcolor{keywordflow}{break};\ \ \ \textcolor{comment}{//\ code\ and\ data\ L2\ cache,\ 6144\ KB,\ 24\ ways,\ 64\ byte\ lines}}
\DoxyCodeLine{00866\ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ 0x78:\ l2\ =\ 1024;\ \textcolor{keywordflow}{break};\ \ \ \textcolor{comment}{//\ code\ and\ data\ L2\ cache,\ 1024\ KB,\ 4\ ways,\ 64\ byte\ lines}}
\DoxyCodeLine{00867\ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ 0x79:\ l2\ =\ 128;\ \textcolor{keywordflow}{break};\ \ \ \textcolor{comment}{//\ code\ and\ data\ L2\ cache,\ 128\ KB,\ 8\ ways,\ 64\ byte\ lines,\ dual-\/sectored}}
\DoxyCodeLine{00868\ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ 0x7A:\ l2\ =\ 256;\ \textcolor{keywordflow}{break};\ \ \ \textcolor{comment}{//\ code\ and\ data\ L2\ cache,\ 256\ KB,\ 8\ ways,\ 64\ byte\ lines,\ dual-\/sectored}}
\DoxyCodeLine{00869\ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ 0x7B:\ l2\ =\ 512;\ \textcolor{keywordflow}{break};\ \ \ \textcolor{comment}{//\ code\ and\ data\ L2\ cache,\ 512\ KB,\ 8\ ways,\ 64\ byte\ lines,\ dual-\/sectored}}
\DoxyCodeLine{00870\ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ 0x7C:\ l2\ =\ 1024;\ \textcolor{keywordflow}{break};\ \ \ \textcolor{comment}{//\ code\ and\ data\ L2\ cache,\ 1024\ KB,\ 8\ ways,\ 64\ byte\ lines,\ dual-\/sectored}}
\DoxyCodeLine{00871\ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ 0x7D:\ l2\ =\ 2048;\ \textcolor{keywordflow}{break};\ \ \ \textcolor{comment}{//\ code\ and\ data\ L2\ cache,\ 2048\ KB,\ 8\ ways,\ 64\ byte\ lines}}
\DoxyCodeLine{00872\ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ 0x7E:\ l2\ =\ 256;\ \textcolor{keywordflow}{break};\ \ \ \textcolor{comment}{//\ code\ and\ data\ L2\ cache,\ 256\ KB,\ 8\ ways,\ 128\ byte\ lines,\ sect.\ (IA-\/64)}}
\DoxyCodeLine{00873\ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ 0x7F:\ l2\ =\ 512;\ \textcolor{keywordflow}{break};\ \ \ \textcolor{comment}{//\ code\ and\ data\ L2\ cache,\ 512\ KB,\ 2\ ways,\ 64\ byte\ lines}}
\DoxyCodeLine{00874\ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ 0x80:\ l2\ =\ 512;\ \textcolor{keywordflow}{break};\ \ \ \textcolor{comment}{//\ code\ and\ data\ L2\ cache,\ 512\ KB,\ 8\ ways,\ 64\ byte\ lines}}
\DoxyCodeLine{00875\ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ 0x81:\ l2\ =\ 128;\ \textcolor{keywordflow}{break};\ \ \ \textcolor{comment}{//\ code\ and\ data\ L2\ cache,\ 128\ KB,\ 8\ ways,\ 32\ byte\ lines}}
\DoxyCodeLine{00876\ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ 0x82:\ l2\ =\ 256;\ \textcolor{keywordflow}{break};\ \ \ \textcolor{comment}{//\ code\ and\ data\ L2\ cache,\ 256\ KB,\ 8\ ways,\ 32\ byte\ lines}}
\DoxyCodeLine{00877\ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ 0x83:\ l2\ =\ 512;\ \textcolor{keywordflow}{break};\ \ \ \textcolor{comment}{//\ code\ and\ data\ L2\ cache,\ 512\ KB,\ 8\ ways,\ 32\ byte\ lines}}
\DoxyCodeLine{00878\ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ 0x84:\ l2\ =\ 1024;\ \textcolor{keywordflow}{break};\ \ \ \textcolor{comment}{//\ code\ and\ data\ L2\ cache,\ 1024\ KB,\ 8\ ways,\ 32\ byte\ lines}}
\DoxyCodeLine{00879\ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ 0x85:\ l2\ =\ 2048;\ \textcolor{keywordflow}{break};\ \ \ \textcolor{comment}{//\ code\ and\ data\ L2\ cache,\ 2048\ KB,\ 8\ ways,\ 32\ byte\ lines}}
\DoxyCodeLine{00880\ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ 0x86:\ l2\ =\ 512;\ \textcolor{keywordflow}{break};\ \ \ \textcolor{comment}{//\ code\ and\ data\ L2\ cache,\ 512\ KB,\ 4\ ways,\ 64\ byte\ lines}}
\DoxyCodeLine{00881\ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ 0x87:\ l2\ =\ 1024;\ \textcolor{keywordflow}{break};\ \ \ \textcolor{comment}{//\ code\ and\ data\ L2\ cache,\ 1024\ KB,\ 8\ ways,\ 64\ byte\ lines}}
\DoxyCodeLine{00882\ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ 0x88:\ l3\ =\ 2048;\ \textcolor{keywordflow}{break};\ \ \ \textcolor{comment}{//\ code\ and\ data\ L3\ cache,\ 2048\ KB,\ 4\ ways,\ 64\ byte\ lines\ (IA-\/64)}}
\DoxyCodeLine{00883\ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ 0x89:\ l3\ =\ 4096;\ \textcolor{keywordflow}{break};\ \ \ \textcolor{comment}{//\ code\ and\ data\ L3\ cache,\ 4096\ KB,\ 4\ ways,\ 64\ byte\ lines\ (IA-\/64)}}
\DoxyCodeLine{00884\ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ 0x8A:\ l3\ =\ 8192;\ \textcolor{keywordflow}{break};\ \ \ \textcolor{comment}{//\ code\ and\ data\ L3\ cache,\ 8192\ KB,\ 4\ ways,\ 64\ byte\ lines\ (IA-\/64)}}
\DoxyCodeLine{00885\ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ 0x8D:\ l3\ =\ 3072;\ \textcolor{keywordflow}{break};\ \ \ \textcolor{comment}{//\ code\ and\ data\ L3\ cache,\ 3072\ KB,\ 12\ ways,\ 128\ byte\ lines\ (IA-\/64)}}
\DoxyCodeLine{00886\ }
\DoxyCodeLine{00887\ \ \ \ \ \ \ \textcolor{keywordflow}{default}:\ \textcolor{keywordflow}{break};}
\DoxyCodeLine{00888\ \ \ \ \ \}}
\DoxyCodeLine{00889\ \ \ \}}
\DoxyCodeLine{00890\ \ \ \textcolor{keywordflow}{if}(check\_for\_p2\_core2\ \&\&\ l2\ ==\ l3)}
\DoxyCodeLine{00891\ \ \ \ \ l3\ =\ 0;}
\DoxyCodeLine{00892\ \ \ l1\ *=\ 1024;}
\DoxyCodeLine{00893\ \ \ l2\ *=\ 1024;}
\DoxyCodeLine{00894\ \ \ l3\ *=\ 1024;}
\DoxyCodeLine{00895\ \}}
\DoxyCodeLine{00896\ }
\DoxyCodeLine{00897\ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{void}\ queryCacheSizes\_intel(\textcolor{keywordtype}{int}\&\ l1,\ \textcolor{keywordtype}{int}\&\ l2,\ \textcolor{keywordtype}{int}\&\ l3,\ \textcolor{keywordtype}{int}\ max\_std\_funcs)}
\DoxyCodeLine{00898\ \{}
\DoxyCodeLine{00899\ \ \ \textcolor{keywordflow}{if}(max\_std\_funcs>=4)}
\DoxyCodeLine{00900\ \ \ \ \ queryCacheSizes\_intel\_direct(l1,l2,l3);}
\DoxyCodeLine{00901\ \ \ \textcolor{keywordflow}{else}}
\DoxyCodeLine{00902\ \ \ \ \ queryCacheSizes\_intel\_codes(l1,l2,l3);}
\DoxyCodeLine{00903\ \}}
\DoxyCodeLine{00904\ }
\DoxyCodeLine{00905\ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{void}\ queryCacheSizes\_amd(\textcolor{keywordtype}{int}\&\ l1,\ \textcolor{keywordtype}{int}\&\ l2,\ \textcolor{keywordtype}{int}\&\ l3)}
\DoxyCodeLine{00906\ \{}
\DoxyCodeLine{00907\ \ \ \textcolor{keywordtype}{int}\ abcd[4];}
\DoxyCodeLine{00908\ \ \ abcd[0]\ =\ abcd[1]\ =\ abcd[2]\ =\ abcd[3]\ =\ 0;}
\DoxyCodeLine{00909\ \ \ EIGEN\_CPUID(abcd,0x80000005,0);}
\DoxyCodeLine{00910\ \ \ l1\ =\ (abcd[2]\ >>\ 24)\ *\ 1024;\ \textcolor{comment}{//\ C[31:24]\ =\ L1\ size\ in\ KB}}
\DoxyCodeLine{00911\ \ \ abcd[0]\ =\ abcd[1]\ =\ abcd[2]\ =\ abcd[3]\ =\ 0;}
\DoxyCodeLine{00912\ \ \ EIGEN\_CPUID(abcd,0x80000006,0);}
\DoxyCodeLine{00913\ \ \ l2\ =\ (abcd[2]\ >>\ 16)\ *\ 1024;\ \textcolor{comment}{//\ C[31;16]\ =\ l2\ cache\ size\ in\ KB}}
\DoxyCodeLine{00914\ \ \ l3\ =\ ((abcd[3]\ \&\ 0xFFFC000)\ >>\ 18)\ *\ 512\ *\ 1024;\ \textcolor{comment}{//\ D[31;18]\ =\ l3\ cache\ size\ in\ 512KB}}
\DoxyCodeLine{00915\ \}}
\DoxyCodeLine{00916\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00917\ }
\DoxyCodeLine{00920\ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{void}\ queryCacheSizes(\textcolor{keywordtype}{int}\&\ l1,\ \textcolor{keywordtype}{int}\&\ l2,\ \textcolor{keywordtype}{int}\&\ l3)}
\DoxyCodeLine{00921\ \{}
\DoxyCodeLine{00922\ \textcolor{preprocessor}{\ \ \#ifdef\ EIGEN\_CPUID}}
\DoxyCodeLine{00923\ \ \ \textcolor{keywordtype}{int}\ abcd[4];}
\DoxyCodeLine{00924\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ GenuineIntel[]\ =\ \{0x756e6547,\ 0x49656e69,\ 0x6c65746e\};}
\DoxyCodeLine{00925\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ AuthenticAMD[]\ =\ \{0x68747541,\ 0x69746e65,\ 0x444d4163\};}
\DoxyCodeLine{00926\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ AMDisbetter\_[]\ =\ \{0x69444d41,\ 0x74656273,\ 0x21726574\};\ \textcolor{comment}{//\ "{}AMDisbetter!"{}}}
\DoxyCodeLine{00927\ }
\DoxyCodeLine{00928\ \ \ \textcolor{comment}{//\ identify\ the\ CPU\ vendor}}
\DoxyCodeLine{00929\ \ \ EIGEN\_CPUID(abcd,0x0,0);}
\DoxyCodeLine{00930\ \ \ \textcolor{keywordtype}{int}\ max\_std\_funcs\ =\ abcd[1];}
\DoxyCodeLine{00931\ \ \ \textcolor{keywordflow}{if}(cpuid\_is\_vendor(abcd,GenuineIntel))}
\DoxyCodeLine{00932\ \ \ \ \ queryCacheSizes\_intel(l1,l2,l3,max\_std\_funcs);}
\DoxyCodeLine{00933\ \ \ \textcolor{keywordflow}{else}\ \textcolor{keywordflow}{if}(cpuid\_is\_vendor(abcd,AuthenticAMD)\ ||\ cpuid\_is\_vendor(abcd,AMDisbetter\_))}
\DoxyCodeLine{00934\ \ \ \ \ queryCacheSizes\_amd(l1,l2,l3);}
\DoxyCodeLine{00935\ \ \ \textcolor{keywordflow}{else}}
\DoxyCodeLine{00936\ \ \ \ \ \textcolor{comment}{//\ by\ default\ let's\ use\ Intel's\ API}}
\DoxyCodeLine{00937\ \ \ \ \ queryCacheSizes\_intel(l1,l2,l3,max\_std\_funcs);}
\DoxyCodeLine{00938\ }
\DoxyCodeLine{00939\ \ \ \textcolor{comment}{//\ here\ is\ the\ list\ of\ other\ vendors:}}
\DoxyCodeLine{00940\ \textcolor{comment}{//\ \ \ ||cpuid\_is\_vendor(abcd,"{}VIA\ VIA\ VIA\ "{})}}
\DoxyCodeLine{00941\ \textcolor{comment}{//\ \ \ ||cpuid\_is\_vendor(abcd,"{}CyrixInstead"{})}}
\DoxyCodeLine{00942\ \textcolor{comment}{//\ \ \ ||cpuid\_is\_vendor(abcd,"{}CentaurHauls"{})}}
\DoxyCodeLine{00943\ \textcolor{comment}{//\ \ \ ||cpuid\_is\_vendor(abcd,"{}GenuineTMx86"{})}}
\DoxyCodeLine{00944\ \textcolor{comment}{//\ \ \ ||cpuid\_is\_vendor(abcd,"{}TransmetaCPU"{})}}
\DoxyCodeLine{00945\ \textcolor{comment}{//\ \ \ ||cpuid\_is\_vendor(abcd,"{}RiseRiseRise"{})}}
\DoxyCodeLine{00946\ \textcolor{comment}{//\ \ \ ||cpuid\_is\_vendor(abcd,"{}Geode\ by\ NSC"{})}}
\DoxyCodeLine{00947\ \textcolor{comment}{//\ \ \ ||cpuid\_is\_vendor(abcd,"{}SiS\ SiS\ SiS\ "{})}}
\DoxyCodeLine{00948\ \textcolor{comment}{//\ \ \ ||cpuid\_is\_vendor(abcd,"{}UMC\ UMC\ UMC\ "{})}}
\DoxyCodeLine{00949\ \textcolor{comment}{//\ \ \ ||cpuid\_is\_vendor(abcd,"{}NexGenDriven"{})}}
\DoxyCodeLine{00950\ \textcolor{preprocessor}{\ \ \#else}}
\DoxyCodeLine{00951\ \ \ l1\ =\ l2\ =\ l3\ =\ -\/1;}
\DoxyCodeLine{00952\ \textcolor{preprocessor}{\ \ \#endif}}
\DoxyCodeLine{00953\ \}}
\DoxyCodeLine{00954\ }
\DoxyCodeLine{00957\ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{int}\ queryL1CacheSize()}
\DoxyCodeLine{00958\ \{}
\DoxyCodeLine{00959\ \ \ \textcolor{keywordtype}{int}\ l1(-\/1),\ l2,\ l3;}
\DoxyCodeLine{00960\ \ \ queryCacheSizes(l1,l2,l3);}
\DoxyCodeLine{00961\ \ \ \textcolor{keywordflow}{return}\ l1;}
\DoxyCodeLine{00962\ \}}
\DoxyCodeLine{00963\ }
\DoxyCodeLine{00966\ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{int}\ queryTopLevelCacheSize()}
\DoxyCodeLine{00967\ \{}
\DoxyCodeLine{00968\ \ \ \textcolor{keywordtype}{int}\ l1,\ l2(-\/1),\ l3(-\/1);}
\DoxyCodeLine{00969\ \ \ queryCacheSizes(l1,l2,l3);}
\DoxyCodeLine{00970\ \ \ \textcolor{keywordflow}{return}\ (std::max)(l2,l3);}
\DoxyCodeLine{00971\ \}}
\DoxyCodeLine{00972\ }
\DoxyCodeLine{00973\ \}\ \textcolor{comment}{//\ end\ namespace\ internal}}
\DoxyCodeLine{00974\ }
\DoxyCodeLine{00975\ \}\ \textcolor{comment}{//\ end\ namespace\ Eigen}}
\DoxyCodeLine{00976\ }
\DoxyCodeLine{00977\ \textcolor{preprocessor}{\#endif\ }\textcolor{comment}{//\ EIGEN\_MEMORY\_H}}

\end{DoxyCode}
