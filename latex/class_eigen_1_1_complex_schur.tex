\doxysection{Eigen\+::Complex\+Schur\texorpdfstring{$<$}{<} \+\_\+\+Matrix\+Type \texorpdfstring{$>$}{>} Class Template Reference}
\hypertarget{class_eigen_1_1_complex_schur}{}\label{class_eigen_1_1_complex_schur}\index{Eigen::ComplexSchur$<$ \_MatrixType $>$@{Eigen::ComplexSchur$<$ \_MatrixType $>$}}


Performs a complex Schur decomposition of a real or complex square matrix.  




{\ttfamily \#include $<$Complex\+Schur.\+h$>$}

\doxysubsubsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
\Hypertarget{class_eigen_1_1_complex_schur_a811eedbda9fd4502a2e357cd1dd05a7d}\label{class_eigen_1_1_complex_schur_a811eedbda9fd4502a2e357cd1dd05a7d} 
enum \{ \newline
{\bfseries Rows\+At\+Compile\+Time} = Matrix\+Type\+::Rows\+At\+Compile\+Time
, {\bfseries Cols\+At\+Compile\+Time} = Matrix\+Type\+::Cols\+At\+Compile\+Time
, {\bfseries Options} = Matrix\+Type\+::Options
, {\bfseries Max\+Rows\+At\+Compile\+Time} = Matrix\+Type\+::Max\+Rows\+At\+Compile\+Time
, \newline
{\bfseries Max\+Cols\+At\+Compile\+Time} = Matrix\+Type\+::Max\+Cols\+At\+Compile\+Time
 \}
\item 
\Hypertarget{class_eigen_1_1_complex_schur_afb9e799fdea51d173e310c82d80d5947}\label{class_eigen_1_1_complex_schur_afb9e799fdea51d173e310c82d80d5947} 
typedef \+\_\+\+Matrix\+Type {\bfseries Matrix\+Type}
\item 
\Hypertarget{class_eigen_1_1_complex_schur_a9a8ee9df37ee1f90d0e53103c58683c0}\label{class_eigen_1_1_complex_schur_a9a8ee9df37ee1f90d0e53103c58683c0} 
typedef Matrix\+Type\+::\+Scalar {\bfseries Scalar}
\begin{DoxyCompactList}\small\item\em Scalar type for matrices of type {\ttfamily \+\_\+\+Matrix\+Type}. \end{DoxyCompactList}\item 
\Hypertarget{class_eigen_1_1_complex_schur_a360081b7ad59db28b9955dea3e4b7dd7}\label{class_eigen_1_1_complex_schur_a360081b7ad59db28b9955dea3e4b7dd7} 
typedef \mbox{\hyperlink{struct_eigen_1_1_num_traits}{Num\+Traits}}$<$ \mbox{\hyperlink{class_eigen_1_1_complex_schur_a9a8ee9df37ee1f90d0e53103c58683c0}{Scalar}} $>$\+::\+Real {\bfseries Real\+Scalar}
\item 
typedef Eigen\+::\+Index \mbox{\hyperlink{class_eigen_1_1_complex_schur_a652104d13723a5b1db2937866a034557}{Index}}
\item 
typedef std\+::complex$<$ Real\+Scalar $>$ \mbox{\hyperlink{class_eigen_1_1_complex_schur_ae1a4713b53f821867fbad617e426832a}{Complex\+Scalar}}
\begin{DoxyCompactList}\small\item\em Complex scalar type for {\ttfamily \+\_\+\+Matrix\+Type}. \end{DoxyCompactList}\item 
typedef \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}}$<$ \mbox{\hyperlink{class_eigen_1_1_complex_schur_ae1a4713b53f821867fbad617e426832a}{Complex\+Scalar}}, Rows\+At\+Compile\+Time, Cols\+At\+Compile\+Time, Options, Max\+Rows\+At\+Compile\+Time, Max\+Cols\+At\+Compile\+Time $>$ \mbox{\hyperlink{class_eigen_1_1_complex_schur_af61fe57877d51cfb50178f78534042f0}{Complex\+Matrix\+Type}}
\begin{DoxyCompactList}\small\item\em Type for the matrices in the Schur decomposition. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{class_eigen_1_1_complex_schur_ad707d9978dc36b3b15e460c2a83f4093}{Complex\+Schur}} (\mbox{\hyperlink{class_eigen_1_1_complex_schur_a652104d13723a5b1db2937866a034557}{Index}} size=Rows\+At\+Compile\+Time==Dynamic ? 1 \+:Rows\+At\+Compile\+Time)
\begin{DoxyCompactList}\small\item\em Default constructor. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Input\+Type $>$ }\\\mbox{\hyperlink{class_eigen_1_1_complex_schur_a9c92c6e4c33890d2d063c5c8dd22777d}{Complex\+Schur}} (const \mbox{\hyperlink{struct_eigen_1_1_eigen_base}{Eigen\+Base}}$<$ Input\+Type $>$ \&matrix, bool computeU=true)
\begin{DoxyCompactList}\small\item\em Constructor; computes Schur decomposition of given matrix. \end{DoxyCompactList}\item 
const \mbox{\hyperlink{class_eigen_1_1_complex_schur_af61fe57877d51cfb50178f78534042f0}{Complex\+Matrix\+Type}} \& \mbox{\hyperlink{class_eigen_1_1_complex_schur_a695d312ce07fc0a82ce5d5ce8cd680da}{matrixU}} () const
\begin{DoxyCompactList}\small\item\em Returns the unitary matrix in the Schur decomposition. \end{DoxyCompactList}\item 
const \mbox{\hyperlink{class_eigen_1_1_complex_schur_af61fe57877d51cfb50178f78534042f0}{Complex\+Matrix\+Type}} \& \mbox{\hyperlink{class_eigen_1_1_complex_schur_a210b9d7e6c26fdde18aa5720da1d3e3c}{matrixT}} () const
\begin{DoxyCompactList}\small\item\em Returns the triangular matrix in the Schur decomposition. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Input\+Type $>$ }\\\mbox{\hyperlink{class_eigen_1_1_complex_schur}{Complex\+Schur}} \& \mbox{\hyperlink{class_eigen_1_1_complex_schur_aedd7040c7b8b79aac600a70f50972602}{compute}} (const \mbox{\hyperlink{struct_eigen_1_1_eigen_base}{Eigen\+Base}}$<$ Input\+Type $>$ \&matrix, bool computeU=true)
\begin{DoxyCompactList}\small\item\em Computes Schur decomposition of given matrix. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Hess\+Matrix\+Type , typename Orth\+Matrix\+Type $>$ }\\\mbox{\hyperlink{class_eigen_1_1_complex_schur}{Complex\+Schur}} \& \mbox{\hyperlink{class_eigen_1_1_complex_schur_a4dd63e98b2900f011cb2d674c1af1fda}{compute\+From\+Hessenberg}} (const Hess\+Matrix\+Type \&matrixH, const Orth\+Matrix\+Type \&matrixQ, bool computeU=true)
\begin{DoxyCompactList}\small\item\em Compute Schur decomposition from a given Hessenberg matrix. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__enums_ga85fad7b87587764e5cf6b513a9e0ee5e}{Computation\+Info}} \mbox{\hyperlink{class_eigen_1_1_complex_schur_a8c5ee15fecfd126fc362c3f2fd28f51e}{info}} () const
\begin{DoxyCompactList}\small\item\em Reports whether previous computation was successful. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_eigen_1_1_complex_schur}{Complex\+Schur}} \& \mbox{\hyperlink{class_eigen_1_1_complex_schur_acf2a88a88657b2aa909e8b25fc2df645}{set\+Max\+Iterations}} (\mbox{\hyperlink{class_eigen_1_1_complex_schur_a652104d13723a5b1db2937866a034557}{Index}} max\+Iters)
\begin{DoxyCompactList}\small\item\em Sets the maximum number of iterations allowed. \end{DoxyCompactList}\item 
\Hypertarget{class_eigen_1_1_complex_schur_a2fc0b7bc409a49e7cdb7b6edcfff26eb}\label{class_eigen_1_1_complex_schur_a2fc0b7bc409a49e7cdb7b6edcfff26eb} 
\mbox{\hyperlink{class_eigen_1_1_complex_schur_a652104d13723a5b1db2937866a034557}{Index}} {\bfseries get\+Max\+Iterations} ()
\begin{DoxyCompactList}\small\item\em Returns the maximum number of iterations. \end{DoxyCompactList}\item 
\Hypertarget{class_eigen_1_1_complex_schur_af7c73af42588d2e56b68ae2ee18d9226}\label{class_eigen_1_1_complex_schur_af7c73af42588d2e56b68ae2ee18d9226} 
{\footnotesize template$<$typename Input\+Type $>$ }\\\mbox{\hyperlink{class_eigen_1_1_complex_schur}{Complex\+Schur}}$<$ Matrix\+Type $>$ \& {\bfseries compute} (const \mbox{\hyperlink{struct_eigen_1_1_eigen_base}{Eigen\+Base}}$<$ Input\+Type $>$ \&matrix, bool computeU)
\item 
\Hypertarget{class_eigen_1_1_complex_schur_a84e2878c311f78d7efa7050795a6f6d3}\label{class_eigen_1_1_complex_schur_a84e2878c311f78d7efa7050795a6f6d3} 
{\footnotesize template$<$typename Hess\+Matrix\+Type , typename Orth\+Matrix\+Type $>$ }\\\mbox{\hyperlink{class_eigen_1_1_complex_schur}{Complex\+Schur}}$<$ Matrix\+Type $>$ \& {\bfseries compute\+From\+Hessenberg} (const Hess\+Matrix\+Type \&matrixH, const Orth\+Matrix\+Type \&matrixQ, bool computeU)
\end{DoxyCompactItemize}
\doxysubsubsection*{Static Public Attributes}
\begin{DoxyCompactItemize}
\item 
static const int \mbox{\hyperlink{class_eigen_1_1_complex_schur_ad37ef6058ce690a1fac4cc524b70cbf0}{m\+\_\+max\+Iterations\+Per\+Row}} = 30
\begin{DoxyCompactList}\small\item\em Maximum number of iterations per row. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
\Hypertarget{class_eigen_1_1_complex_schur_a1ae856aee520ee8fca06376fc7fd8b6a}\label{class_eigen_1_1_complex_schur_a1ae856aee520ee8fca06376fc7fd8b6a} 
\mbox{\hyperlink{class_eigen_1_1_complex_schur_af61fe57877d51cfb50178f78534042f0}{Complex\+Matrix\+Type}} {\bfseries m\+\_\+matT}
\item 
\Hypertarget{class_eigen_1_1_complex_schur_a53fefee5d25b8853fbd0b2c4f0873a9a}\label{class_eigen_1_1_complex_schur_a53fefee5d25b8853fbd0b2c4f0873a9a} 
\mbox{\hyperlink{class_eigen_1_1_complex_schur_af61fe57877d51cfb50178f78534042f0}{Complex\+Matrix\+Type}} {\bfseries m\+\_\+matU}
\item 
\Hypertarget{class_eigen_1_1_complex_schur_afa2fb01289186fe882d7db7f2493b0ec}\label{class_eigen_1_1_complex_schur_afa2fb01289186fe882d7db7f2493b0ec} 
\mbox{\hyperlink{class_eigen_1_1_hessenberg_decomposition}{Hessenberg\+Decomposition}}$<$ Matrix\+Type $>$ {\bfseries m\+\_\+hess}
\item 
\Hypertarget{class_eigen_1_1_complex_schur_adb18a90a2087d7a89253275d311418c6}\label{class_eigen_1_1_complex_schur_adb18a90a2087d7a89253275d311418c6} 
\mbox{\hyperlink{group__enums_ga85fad7b87587764e5cf6b513a9e0ee5e}{Computation\+Info}} {\bfseries m\+\_\+info}
\item 
\Hypertarget{class_eigen_1_1_complex_schur_a48e29539f604b170a3e757f5cbeeb818}\label{class_eigen_1_1_complex_schur_a48e29539f604b170a3e757f5cbeeb818} 
bool {\bfseries m\+\_\+is\+Initialized}
\item 
\Hypertarget{class_eigen_1_1_complex_schur_a8a6b06445c8c2a10191052880cadb7cd}\label{class_eigen_1_1_complex_schur_a8a6b06445c8c2a10191052880cadb7cd} 
bool {\bfseries m\+\_\+mat\+Uis\+Uptodate}
\item 
\Hypertarget{class_eigen_1_1_complex_schur_a2e55a5d20381f8f898872f318d591785}\label{class_eigen_1_1_complex_schur_a2e55a5d20381f8f898872f318d591785} 
\mbox{\hyperlink{class_eigen_1_1_complex_schur_a652104d13723a5b1db2937866a034557}{Index}} {\bfseries m\+\_\+max\+Iters}
\end{DoxyCompactItemize}
\doxysubsubsection*{Friends}
\begin{DoxyCompactItemize}
\item 
\Hypertarget{class_eigen_1_1_complex_schur_ad25f2162da857c1114ed0383648a7728}\label{class_eigen_1_1_complex_schur_ad25f2162da857c1114ed0383648a7728} 
struct {\bfseries internal\+::complex\+\_\+schur\+\_\+reduce\+\_\+to\+\_\+hessenberg$<$ Matrix\+Type, Num\+Traits$<$ Scalar $>$\+::\+Is\+Complex $>$}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\subsubsection*{template$<$typename \+\_\+\+Matrix\+Type$>$\newline
class Eigen\+::\+Complex\+Schur$<$ \+\_\+\+Matrix\+Type $>$}
Performs a complex Schur decomposition of a real or complex square matrix. 

\textbackslash{}eigenvalues\+\_\+module


\begin{DoxyTemplParams}{Template Parameters}
{\em \+\_\+\+Matrix\+Type} & the type of the matrix of which we are computing the Schur decomposition; this is expected to be an instantiation of the \doxylink{class_eigen_1_1_matrix}{Matrix} class template.\\
\hline
\end{DoxyTemplParams}
Given a real or complex square matrix A, this class computes the Schur decomposition\+: $ A = U T U^*$ where U is a unitary complex matrix, and T is a complex upper triangular matrix. The diagonal of the matrix T corresponds to the eigenvalues of the matrix A.

Call the function \doxylink{class_eigen_1_1_complex_schur_aedd7040c7b8b79aac600a70f50972602}{compute()} to compute the Schur decomposition of a given matrix. Alternatively, you can use the Complex\+Schur(const Matrix\+Type\&, bool) constructor which computes the Schur decomposition at construction time. Once the decomposition is computed, you can use the \doxylink{class_eigen_1_1_complex_schur_a695d312ce07fc0a82ce5d5ce8cd680da}{matrix\+U()} and \doxylink{class_eigen_1_1_complex_schur_a210b9d7e6c26fdde18aa5720da1d3e3c}{matrix\+T()} functions to retrieve the matrices U and V in the decomposition.

\begin{DoxyNote}{Note}
This code is inspired from Jampack
\end{DoxyNote}
\begin{DoxySeeAlso}{See also}
class \doxylink{class_eigen_1_1_real_schur}{Real\+Schur}, class \doxylink{class_eigen_1_1_eigen_solver}{Eigen\+Solver}, class \doxylink{class_eigen_1_1_complex_eigen_solver}{Complex\+Eigen\+Solver} 
\end{DoxySeeAlso}


\doxysubsection{Member Typedef Documentation}
\Hypertarget{class_eigen_1_1_complex_schur_af61fe57877d51cfb50178f78534042f0}\index{Eigen::ComplexSchur$<$ \_MatrixType $>$@{Eigen::ComplexSchur$<$ \_MatrixType $>$}!ComplexMatrixType@{ComplexMatrixType}}
\index{ComplexMatrixType@{ComplexMatrixType}!Eigen::ComplexSchur$<$ \_MatrixType $>$@{Eigen::ComplexSchur$<$ \_MatrixType $>$}}
\doxysubsubsection{\texorpdfstring{ComplexMatrixType}{ComplexMatrixType}}
{\footnotesize\ttfamily \label{class_eigen_1_1_complex_schur_af61fe57877d51cfb50178f78534042f0} 
template$<$typename \+\_\+\+Matrix\+Type $>$ \\
typedef \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}}$<$\mbox{\hyperlink{class_eigen_1_1_complex_schur_ae1a4713b53f821867fbad617e426832a}{Complex\+Scalar}}, Rows\+At\+Compile\+Time, Cols\+At\+Compile\+Time, Options, Max\+Rows\+At\+Compile\+Time, Max\+Cols\+At\+Compile\+Time$>$ \mbox{\hyperlink{class_eigen_1_1_complex_schur}{Eigen\+::\+Complex\+Schur}}$<$ \+\_\+\+Matrix\+Type $>$\+::\+Complex\+Matrix\+Type}



Type for the matrices in the Schur decomposition. 

This is a square matrix with entries of type \doxylink{class_eigen_1_1_complex_schur_ae1a4713b53f821867fbad617e426832a}{Complex\+Scalar}. The size is the same as the size of {\ttfamily \+\_\+\+Matrix\+Type}. \Hypertarget{class_eigen_1_1_complex_schur_ae1a4713b53f821867fbad617e426832a}\index{Eigen::ComplexSchur$<$ \_MatrixType $>$@{Eigen::ComplexSchur$<$ \_MatrixType $>$}!ComplexScalar@{ComplexScalar}}
\index{ComplexScalar@{ComplexScalar}!Eigen::ComplexSchur$<$ \_MatrixType $>$@{Eigen::ComplexSchur$<$ \_MatrixType $>$}}
\doxysubsubsection{\texorpdfstring{ComplexScalar}{ComplexScalar}}
{\footnotesize\ttfamily \label{class_eigen_1_1_complex_schur_ae1a4713b53f821867fbad617e426832a} 
template$<$typename \+\_\+\+Matrix\+Type $>$ \\
typedef std\+::complex$<$Real\+Scalar$>$ \mbox{\hyperlink{class_eigen_1_1_complex_schur}{Eigen\+::\+Complex\+Schur}}$<$ \+\_\+\+Matrix\+Type $>$\+::\+Complex\+Scalar}



Complex scalar type for {\ttfamily \+\_\+\+Matrix\+Type}. 

This is {\ttfamily std\+::complex$<$\+Scalar$>$} if \doxylink{class_eigen_1_1_complex_schur_a9a8ee9df37ee1f90d0e53103c58683c0}{Scalar} is real (e.\+g., {\ttfamily float} or {\ttfamily double}) and just {\ttfamily Scalar} if \doxylink{class_eigen_1_1_complex_schur_a9a8ee9df37ee1f90d0e53103c58683c0}{Scalar} is complex. \Hypertarget{class_eigen_1_1_complex_schur_a652104d13723a5b1db2937866a034557}\index{Eigen::ComplexSchur$<$ \_MatrixType $>$@{Eigen::ComplexSchur$<$ \_MatrixType $>$}!Index@{Index}}
\index{Index@{Index}!Eigen::ComplexSchur$<$ \_MatrixType $>$@{Eigen::ComplexSchur$<$ \_MatrixType $>$}}
\doxysubsubsection{\texorpdfstring{Index}{Index}}
{\footnotesize\ttfamily \label{class_eigen_1_1_complex_schur_a652104d13723a5b1db2937866a034557} 
template$<$typename \+\_\+\+Matrix\+Type $>$ \\
typedef Eigen\+::\+Index \mbox{\hyperlink{class_eigen_1_1_complex_schur}{Eigen\+::\+Complex\+Schur}}$<$ \+\_\+\+Matrix\+Type $>$\+::\+Index}

\begin{DoxyRefDesc}{Deprecated}
\item[\mbox{\hyperlink{deprecated__deprecated000018}{Deprecated}}]since Eigen 3.\+3 \end{DoxyRefDesc}


\doxysubsection{Constructor \& Destructor Documentation}
\Hypertarget{class_eigen_1_1_complex_schur_ad707d9978dc36b3b15e460c2a83f4093}\index{Eigen::ComplexSchur$<$ \_MatrixType $>$@{Eigen::ComplexSchur$<$ \_MatrixType $>$}!ComplexSchur@{ComplexSchur}}
\index{ComplexSchur@{ComplexSchur}!Eigen::ComplexSchur$<$ \_MatrixType $>$@{Eigen::ComplexSchur$<$ \_MatrixType $>$}}
\doxysubsubsection{\texorpdfstring{ComplexSchur()}{ComplexSchur()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{class_eigen_1_1_complex_schur_ad707d9978dc36b3b15e460c2a83f4093} 
template$<$typename \+\_\+\+Matrix\+Type $>$ \\
\mbox{\hyperlink{class_eigen_1_1_complex_schur}{Eigen\+::\+Complex\+Schur}}$<$ \+\_\+\+Matrix\+Type $>$\+::\+Complex\+Schur (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_eigen_1_1_complex_schur_a652104d13723a5b1db2937866a034557}{Index}}}]{size}{ = {\ttfamily RowsAtCompileTime==Dynamic~?~1~\+:~RowsAtCompileTime}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [explicit]}}



Default constructor. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em size} & Positive integer, size of the matrix whose Schur decomposition will be computed.\\
\hline
\end{DoxyParams}
The default constructor is useful in cases in which the user intends to perform decompositions via \doxylink{class_eigen_1_1_complex_schur_aedd7040c7b8b79aac600a70f50972602}{compute()}. The {\ttfamily size} parameter is only used as a hint. It is not an error to give a wrong {\ttfamily size}, but it may impair performance.

\begin{DoxySeeAlso}{See also}
\doxylink{class_eigen_1_1_complex_schur_aedd7040c7b8b79aac600a70f50972602}{compute()} for an example. 
\end{DoxySeeAlso}
\Hypertarget{class_eigen_1_1_complex_schur_a9c92c6e4c33890d2d063c5c8dd22777d}\index{Eigen::ComplexSchur$<$ \_MatrixType $>$@{Eigen::ComplexSchur$<$ \_MatrixType $>$}!ComplexSchur@{ComplexSchur}}
\index{ComplexSchur@{ComplexSchur}!Eigen::ComplexSchur$<$ \_MatrixType $>$@{Eigen::ComplexSchur$<$ \_MatrixType $>$}}
\doxysubsubsection{\texorpdfstring{ComplexSchur()}{ComplexSchur()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{class_eigen_1_1_complex_schur_a9c92c6e4c33890d2d063c5c8dd22777d} 
template$<$typename \+\_\+\+Matrix\+Type $>$ \\
template$<$typename Input\+Type $>$ \\
\mbox{\hyperlink{class_eigen_1_1_complex_schur}{Eigen\+::\+Complex\+Schur}}$<$ \+\_\+\+Matrix\+Type $>$\+::\+Complex\+Schur (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{struct_eigen_1_1_eigen_base}{Eigen\+Base}}$<$ Input\+Type $>$ \&}]{matrix}{, }\item[{bool}]{computeU}{ = {\ttfamily true}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [explicit]}}



Constructor; computes Schur decomposition of given matrix. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em matrix} & Square matrix whose Schur decomposition is to be computed. \\
\hline
\mbox{\texttt{ in}}  & {\em computeU} & If true, both T and U are computed; if false, only T is computed.\\
\hline
\end{DoxyParams}
This constructor calls \doxylink{class_eigen_1_1_complex_schur_aedd7040c7b8b79aac600a70f50972602}{compute()} to compute the Schur decomposition.

\begin{DoxySeeAlso}{See also}
\doxylink{class_eigen_1_1_complex_schur_a210b9d7e6c26fdde18aa5720da1d3e3c}{matrix\+T()} and \doxylink{class_eigen_1_1_complex_schur_a695d312ce07fc0a82ce5d5ce8cd680da}{matrix\+U()} for examples. 
\end{DoxySeeAlso}


\doxysubsection{Member Function Documentation}
\Hypertarget{class_eigen_1_1_complex_schur_aedd7040c7b8b79aac600a70f50972602}\index{Eigen::ComplexSchur$<$ \_MatrixType $>$@{Eigen::ComplexSchur$<$ \_MatrixType $>$}!compute@{compute}}
\index{compute@{compute}!Eigen::ComplexSchur$<$ \_MatrixType $>$@{Eigen::ComplexSchur$<$ \_MatrixType $>$}}
\doxysubsubsection{\texorpdfstring{compute()}{compute()}}
{\footnotesize\ttfamily \label{class_eigen_1_1_complex_schur_aedd7040c7b8b79aac600a70f50972602} 
template$<$typename \+\_\+\+Matrix\+Type $>$ \\
template$<$typename Input\+Type $>$ \\
\mbox{\hyperlink{class_eigen_1_1_complex_schur}{Complex\+Schur}} \& \mbox{\hyperlink{class_eigen_1_1_complex_schur}{Eigen\+::\+Complex\+Schur}}$<$ \+\_\+\+Matrix\+Type $>$\+::compute (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{struct_eigen_1_1_eigen_base}{Eigen\+Base}}$<$ Input\+Type $>$ \&}]{matrix}{, }\item[{bool}]{computeU}{ = {\ttfamily true}}\end{DoxyParamCaption})}



Computes Schur decomposition of given matrix. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em matrix} & Square matrix whose Schur decomposition is to be computed. \\
\hline
\mbox{\texttt{ in}}  & {\em computeU} & If true, both T and U are computed; if false, only T is computed.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Reference to {\ttfamily \texorpdfstring{$\ast$}{*}this} 
\end{DoxyReturn}
The Schur decomposition is computed by first reducing the matrix to Hessenberg form using the class \doxylink{class_eigen_1_1_hessenberg_decomposition}{Hessenberg\+Decomposition}. The Hessenberg matrix is then reduced to triangular form by performing QR iterations with a single shift. The cost of computing the Schur decomposition depends on the number of iterations; as a rough guide, it may be taken on the number of iterations; as a rough guide, it may be taken to be $25n^3$ complex flops, or $10n^3$ complex flops if {\itshape computeU} is false.

Example\+: 
\begin{DoxyCodeInclude}{0}

\end{DoxyCodeInclude}
 Output\+: 
\begin{DoxyVerbInclude}
\end{DoxyVerbInclude}


\begin{DoxySeeAlso}{See also}
compute(const Matrix\+Type\&, bool, Index) 
\end{DoxySeeAlso}
\Hypertarget{class_eigen_1_1_complex_schur_a4dd63e98b2900f011cb2d674c1af1fda}\index{Eigen::ComplexSchur$<$ \_MatrixType $>$@{Eigen::ComplexSchur$<$ \_MatrixType $>$}!computeFromHessenberg@{computeFromHessenberg}}
\index{computeFromHessenberg@{computeFromHessenberg}!Eigen::ComplexSchur$<$ \_MatrixType $>$@{Eigen::ComplexSchur$<$ \_MatrixType $>$}}
\doxysubsubsection{\texorpdfstring{computeFromHessenberg()}{computeFromHessenberg()}}
{\footnotesize\ttfamily \label{class_eigen_1_1_complex_schur_a4dd63e98b2900f011cb2d674c1af1fda} 
template$<$typename \+\_\+\+Matrix\+Type $>$ \\
template$<$typename Hess\+Matrix\+Type , typename Orth\+Matrix\+Type $>$ \\
\mbox{\hyperlink{class_eigen_1_1_complex_schur}{Complex\+Schur}} \& \mbox{\hyperlink{class_eigen_1_1_complex_schur}{Eigen\+::\+Complex\+Schur}}$<$ \+\_\+\+Matrix\+Type $>$\+::compute\+From\+Hessenberg (\begin{DoxyParamCaption}\item[{const Hess\+Matrix\+Type \&}]{matrixH}{, }\item[{const Orth\+Matrix\+Type \&}]{matrixQ}{, }\item[{bool}]{computeU}{ = {\ttfamily true}}\end{DoxyParamCaption})}



Compute Schur decomposition from a given Hessenberg matrix. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em matrixH} & \doxylink{class_eigen_1_1_matrix}{Matrix} in Hessenberg form H \\
\hline
\mbox{\texttt{ in}}  & {\em matrixQ} & orthogonal matrix Q that transform a matrix A to H \+: A = Q H Q\texorpdfstring{$^\wedge$}{\string^}T \\
\hline
 & {\em computeU} & Computes the matriX U of the Schur vectors \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Reference to {\ttfamily \texorpdfstring{$\ast$}{*}this} 
\end{DoxyReturn}
This routine assumes that the matrix is already reduced in Hessenberg form matrixH using either the class \doxylink{class_eigen_1_1_hessenberg_decomposition}{Hessenberg\+Decomposition} or another mean. It computes the upper quasi-\/triangular matrix T of the Schur decomposition of H When computeU is true, this routine computes the matrix U such that A = U T U\texorpdfstring{$^\wedge$}{\string^}T = (QZ) T (QZ)\texorpdfstring{$^\wedge$}{\string^}T = Q H Q\texorpdfstring{$^\wedge$}{\string^}T where A is the initial matrix

NOTE Q is referenced if computeU is true; so, if the initial orthogonal matrix is not available, the user should give an identity matrix (Q.\+set\+Identity())

\begin{DoxySeeAlso}{See also}
compute(const Matrix\+Type\&, bool) 
\end{DoxySeeAlso}
\Hypertarget{class_eigen_1_1_complex_schur_a8c5ee15fecfd126fc362c3f2fd28f51e}\index{Eigen::ComplexSchur$<$ \_MatrixType $>$@{Eigen::ComplexSchur$<$ \_MatrixType $>$}!info@{info}}
\index{info@{info}!Eigen::ComplexSchur$<$ \_MatrixType $>$@{Eigen::ComplexSchur$<$ \_MatrixType $>$}}
\doxysubsubsection{\texorpdfstring{info()}{info()}}
{\footnotesize\ttfamily \label{class_eigen_1_1_complex_schur_a8c5ee15fecfd126fc362c3f2fd28f51e} 
template$<$typename \+\_\+\+Matrix\+Type $>$ \\
\mbox{\hyperlink{group__enums_ga85fad7b87587764e5cf6b513a9e0ee5e}{Computation\+Info}} \mbox{\hyperlink{class_eigen_1_1_complex_schur}{Eigen\+::\+Complex\+Schur}}$<$ \+\_\+\+Matrix\+Type $>$\+::info (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Reports whether previous computation was successful. 

\begin{DoxyReturn}{Returns}
{\ttfamily Success} if computation was succesful, {\ttfamily No\+Convergence} otherwise. 
\end{DoxyReturn}
\Hypertarget{class_eigen_1_1_complex_schur_a210b9d7e6c26fdde18aa5720da1d3e3c}\index{Eigen::ComplexSchur$<$ \_MatrixType $>$@{Eigen::ComplexSchur$<$ \_MatrixType $>$}!matrixT@{matrixT}}
\index{matrixT@{matrixT}!Eigen::ComplexSchur$<$ \_MatrixType $>$@{Eigen::ComplexSchur$<$ \_MatrixType $>$}}
\doxysubsubsection{\texorpdfstring{matrixT()}{matrixT()}}
{\footnotesize\ttfamily \label{class_eigen_1_1_complex_schur_a210b9d7e6c26fdde18aa5720da1d3e3c} 
template$<$typename \+\_\+\+Matrix\+Type $>$ \\
const \mbox{\hyperlink{class_eigen_1_1_complex_schur_af61fe57877d51cfb50178f78534042f0}{Complex\+Matrix\+Type}} \& \mbox{\hyperlink{class_eigen_1_1_complex_schur}{Eigen\+::\+Complex\+Schur}}$<$ \+\_\+\+Matrix\+Type $>$\+::matrixT (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Returns the triangular matrix in the Schur decomposition. 

\begin{DoxyReturn}{Returns}
A const reference to the matrix T.
\end{DoxyReturn}
It is assumed that either the constructor Complex\+Schur(const Matrix\+Type\& matrix, bool compute\+U) or the member function compute(const Matrix\+Type\& matrix, bool compute\+U) has been called before to compute the Schur decomposition of a matrix.

Note that this function returns a plain square matrix. If you want to reference only the upper triangular part, use\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{schur.matrixT().triangularView<\mbox{\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cdafca2ccebb604f171656deb53e8c083c1}{Upper}}>()\ }

\end{DoxyCode}


Example\+: 
\begin{DoxyCodeInclude}{0}

\end{DoxyCodeInclude}
 Output\+: 
\begin{DoxyVerbInclude}
\end{DoxyVerbInclude}
 \Hypertarget{class_eigen_1_1_complex_schur_a695d312ce07fc0a82ce5d5ce8cd680da}\index{Eigen::ComplexSchur$<$ \_MatrixType $>$@{Eigen::ComplexSchur$<$ \_MatrixType $>$}!matrixU@{matrixU}}
\index{matrixU@{matrixU}!Eigen::ComplexSchur$<$ \_MatrixType $>$@{Eigen::ComplexSchur$<$ \_MatrixType $>$}}
\doxysubsubsection{\texorpdfstring{matrixU()}{matrixU()}}
{\footnotesize\ttfamily \label{class_eigen_1_1_complex_schur_a695d312ce07fc0a82ce5d5ce8cd680da} 
template$<$typename \+\_\+\+Matrix\+Type $>$ \\
const \mbox{\hyperlink{class_eigen_1_1_complex_schur_af61fe57877d51cfb50178f78534042f0}{Complex\+Matrix\+Type}} \& \mbox{\hyperlink{class_eigen_1_1_complex_schur}{Eigen\+::\+Complex\+Schur}}$<$ \+\_\+\+Matrix\+Type $>$\+::matrixU (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Returns the unitary matrix in the Schur decomposition. 

\begin{DoxyReturn}{Returns}
A const reference to the matrix U.
\end{DoxyReturn}
It is assumed that either the constructor Complex\+Schur(const Matrix\+Type\& matrix, bool compute\+U) or the member function compute(const Matrix\+Type\& matrix, bool compute\+U) has been called before to compute the Schur decomposition of a matrix, and that {\ttfamily computeU} was set to true (the default value).

Example\+: 
\begin{DoxyCodeInclude}{0}

\end{DoxyCodeInclude}
 Output\+: 
\begin{DoxyVerbInclude}
\end{DoxyVerbInclude}
 \Hypertarget{class_eigen_1_1_complex_schur_acf2a88a88657b2aa909e8b25fc2df645}\index{Eigen::ComplexSchur$<$ \_MatrixType $>$@{Eigen::ComplexSchur$<$ \_MatrixType $>$}!setMaxIterations@{setMaxIterations}}
\index{setMaxIterations@{setMaxIterations}!Eigen::ComplexSchur$<$ \_MatrixType $>$@{Eigen::ComplexSchur$<$ \_MatrixType $>$}}
\doxysubsubsection{\texorpdfstring{setMaxIterations()}{setMaxIterations()}}
{\footnotesize\ttfamily \label{class_eigen_1_1_complex_schur_acf2a88a88657b2aa909e8b25fc2df645} 
template$<$typename \+\_\+\+Matrix\+Type $>$ \\
\mbox{\hyperlink{class_eigen_1_1_complex_schur}{Complex\+Schur}} \& \mbox{\hyperlink{class_eigen_1_1_complex_schur}{Eigen\+::\+Complex\+Schur}}$<$ \+\_\+\+Matrix\+Type $>$\+::set\+Max\+Iterations (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_eigen_1_1_complex_schur_a652104d13723a5b1db2937866a034557}{Index}}}]{max\+Iters}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Sets the maximum number of iterations allowed. 

If not specified by the user, the maximum number of iterations is m\+\_\+max\+Iterations\+Per\+Row times the size of the matrix. 

\doxysubsection{Member Data Documentation}
\Hypertarget{class_eigen_1_1_complex_schur_ad37ef6058ce690a1fac4cc524b70cbf0}\index{Eigen::ComplexSchur$<$ \_MatrixType $>$@{Eigen::ComplexSchur$<$ \_MatrixType $>$}!m\_maxIterationsPerRow@{m\_maxIterationsPerRow}}
\index{m\_maxIterationsPerRow@{m\_maxIterationsPerRow}!Eigen::ComplexSchur$<$ \_MatrixType $>$@{Eigen::ComplexSchur$<$ \_MatrixType $>$}}
\doxysubsubsection{\texorpdfstring{m\_maxIterationsPerRow}{m\_maxIterationsPerRow}}
{\footnotesize\ttfamily \label{class_eigen_1_1_complex_schur_ad37ef6058ce690a1fac4cc524b70cbf0} 
template$<$typename \+\_\+\+Matrix\+Type $>$ \\
const int \mbox{\hyperlink{class_eigen_1_1_complex_schur}{Eigen\+::\+Complex\+Schur}}$<$ \+\_\+\+Matrix\+Type $>$\+::m\+\_\+max\+Iterations\+Per\+Row = 30\hspace{0.3cm}{\ttfamily [static]}}



Maximum number of iterations per row. 

If not otherwise specified, the maximum number of iterations is this number times the size of the matrix. It is currently set to 30. 

The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
packages/\+Eigen.\+3.\+3.\+3/build/native/include/\+Eigen/src/\+Eigenvalues/Complex\+Schur.\+h\end{DoxyCompactItemize}
